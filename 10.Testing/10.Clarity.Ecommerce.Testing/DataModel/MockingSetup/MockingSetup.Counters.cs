// <autogenerated>
// <copyright file="Counters.MockingSetup.cs" company="clarity-ventures.com">
// Copyright (c) 2016-2023 clarity-ventures.com. All rights reserved.
// </copyright>
// <summary>Implements the Counters section of the Mocking Setup class</summary>
// <remarks>This file was auto-generated by MockingSetupMaster.tt, changes to this
// file will be overwritten automatically when the T4 template is run again</remarks>
// </autogenerated>
// ReSharper disable CyclomaticComplexity, FunctionComplexityOverflow
#pragma warning disable CS0618 // Obsolete Items warnings ignored inside T4
#pragma warning disable CS1998 // Async method lacks 'await' operators and will run synchronously ignored inside T4
#nullable enable
namespace Clarity.Ecommerce.Testing
{
    using System;
    using System.Collections.Generic;
    using System.Data.Entity;
    using System.Linq;
    using System.Threading.Tasks;
    using DataModel;
    using Interfaces.DataModel;
    using Moq;

    public partial class MockingSetup
    {
        // Enable the entire schema on run
        public bool DoCounters { private get; set; }

        // Enable the tables specifically on run
        public bool DoCounterTable { private get; set; }
        public bool DoCounterLogTable { private get; set; }
        public bool DoCounterLogTypeTable { private get; set; }
        public bool DoCounterTypeTable { private get; set; }

        // Dirty Checking
        public bool CounterDirty { private get; set; }
        public bool CounterLogDirty { private get; set; }
        public bool CounterLogTypeDirty { private get; set; }
        public bool CounterTypeDirty { private get; set; }

        // Sets
        public Mock<DbSet<Counter>>? Counters { get; private set; }
        public Mock<DbSet<CounterLog>>? CounterLogs { get; private set; }
        public Mock<DbSet<CounterLogType>>? CounterLogTypes { get; private set; }
        public Mock<DbSet<CounterType>>? CounterTypes { get; private set; }

        // Raw Data
        public List<Mock<Counter>>? RawCounters { get; private set; }
        public List<Mock<CounterLog>>? RawCounterLogs { get; private set; }
        public List<Mock<CounterLogType>>? RawCounterLogTypes { get; private set; }
        public List<Mock<CounterType>>? RawCounterTypes { get; private set; }

        [System.Diagnostics.DebuggerStepThrough]
        public async Task AssignSchemaMocksCountersAsync(Mock<IClarityEcommerceEntities> context, bool dirtyOnly)
        {
            if (DoAll || DoCounters || (DoCounterTable && (!dirtyOnly || CounterDirty)))
            {
                var attempts = 0;
                await RetryHelper.RetryOnExceptionAsync(async () =>
                {
                    if (++attempts > 1) { System.Diagnostics.Debug.WriteLine($"Assign Schema Mocks is taking extra attempts: {attempts}"); }
                    if (RawCounters == null) { throw new InvalidOperationException("Raw Counters was null"); }
                    await InitializeMockSetFromListAsync(Counters, RawCounters).ConfigureAwait(false);
                    context.Setup(m => m.Counters).Returns(() => Counters?.Object!);
                    context.Setup(m => m.Set<Counter>()).Returns(() => Counters?.Object!);
                })
                .ConfigureAwait(false);
            }
            if (DoAll || DoCounters || (DoCounterLogTable && (!dirtyOnly || CounterLogDirty)))
            {
                var attempts = 0;
                await RetryHelper.RetryOnExceptionAsync(async () =>
                {
                    if (++attempts > 1) { System.Diagnostics.Debug.WriteLine($"Assign Schema Mocks is taking extra attempts: {attempts}"); }
                    if (RawCounterLogs == null) { throw new InvalidOperationException("Raw CounterLogs was null"); }
                    await InitializeMockSetFromListAsync(CounterLogs, RawCounterLogs).ConfigureAwait(false);
                    context.Setup(m => m.CounterLogs).Returns(() => CounterLogs?.Object!);
                    context.Setup(m => m.Set<CounterLog>()).Returns(() => CounterLogs?.Object!);
                })
                .ConfigureAwait(false);
            }
            if (DoAll || DoCounters || (DoCounterLogTypeTable && (!dirtyOnly || CounterLogTypeDirty)))
            {
                var attempts = 0;
                await RetryHelper.RetryOnExceptionAsync(async () =>
                {
                    if (++attempts > 1) { System.Diagnostics.Debug.WriteLine($"Assign Schema Mocks is taking extra attempts: {attempts}"); }
                    if (RawCounterLogTypes == null) { throw new InvalidOperationException("Raw CounterLogTypes was null"); }
                    await InitializeMockSetFromListAsync(CounterLogTypes, RawCounterLogTypes).ConfigureAwait(false);
                    context.Setup(m => m.CounterLogTypes).Returns(() => CounterLogTypes?.Object!);
                    context.Setup(m => m.Set<CounterLogType>()).Returns(() => CounterLogTypes?.Object!);
                })
                .ConfigureAwait(false);
            }
            if (DoAll || DoCounters || (DoCounterTypeTable && (!dirtyOnly || CounterTypeDirty)))
            {
                var attempts = 0;
                await RetryHelper.RetryOnExceptionAsync(async () =>
                {
                    if (++attempts > 1) { System.Diagnostics.Debug.WriteLine($"Assign Schema Mocks is taking extra attempts: {attempts}"); }
                    if (RawCounterTypes == null) { throw new InvalidOperationException("Raw CounterTypes was null"); }
                    await InitializeMockSetFromListAsync(CounterTypes, RawCounterTypes).ConfigureAwait(false);
                    context.Setup(m => m.CounterTypes).Returns(() => CounterTypes?.Object!);
                    context.Setup(m => m.Set<CounterType>()).Returns(() => CounterTypes?.Object!);
                })
                .ConfigureAwait(false);
            }
        }

        [System.Diagnostics.DebuggerStepThrough]
        private async Task InitializeMockSetCountersAsync(Mock<IClarityEcommerceEntities> context, List<Mock<Counter>> data)
        {
            if (!DoAll && !DoCounters && !DoCounterTable) { return; }
            Counters ??= new Mock<DbSet<Counter>>();
            await InitializeMockSetFromListAsync(Counters, data).ConfigureAwait(false);
            context.Setup(m => m.Counters).Returns(() => Counters.Object);
            context.Setup(m => m.Set<Counter>()).Returns(() => Counters.Object);
            TableRecordCounts[typeof(Counter)] = data.Count;
            if (data.Any())
            {
                TableFirstRecordIDs[typeof(Counter)] = data[0].Object.ID;
                TableFirstRecordCustomKeys[typeof(Counter)] = data[0].Object.CustomKey;
            }
        }

        [System.Diagnostics.DebuggerStepThrough]
        private async Task InitializeMockSetCounterLogsAsync(Mock<IClarityEcommerceEntities> context, List<Mock<CounterLog>> data)
        {
            if (!DoAll && !DoCounters && !DoCounterLogTable) { return; }
            CounterLogs ??= new Mock<DbSet<CounterLog>>();
            await InitializeMockSetFromListAsync(CounterLogs, data).ConfigureAwait(false);
            context.Setup(m => m.CounterLogs).Returns(() => CounterLogs.Object);
            context.Setup(m => m.Set<CounterLog>()).Returns(() => CounterLogs.Object);
            TableRecordCounts[typeof(CounterLog)] = data.Count;
            if (data.Any())
            {
                TableFirstRecordIDs[typeof(CounterLog)] = data[0].Object.ID;
                TableFirstRecordCustomKeys[typeof(CounterLog)] = data[0].Object.CustomKey;
            }
        }

        [System.Diagnostics.DebuggerStepThrough]
        private async Task InitializeMockSetCounterLogTypesAsync(Mock<IClarityEcommerceEntities> context, List<Mock<CounterLogType>> data)
        {
            if (!DoAll && !DoCounters && !DoCounterLogTypeTable) { return; }
            CounterLogTypes ??= new Mock<DbSet<CounterLogType>>();
            await InitializeMockSetFromListAsync(CounterLogTypes, data).ConfigureAwait(false);
            context.Setup(m => m.CounterLogTypes).Returns(() => CounterLogTypes.Object);
            context.Setup(m => m.Set<CounterLogType>()).Returns(() => CounterLogTypes.Object);
            TableRecordCounts[typeof(CounterLogType)] = data.Count;
            if (data.Any())
            {
                TableFirstRecordIDs[typeof(CounterLogType)] = data[0].Object.ID;
                TableFirstRecordCustomKeys[typeof(CounterLogType)] = data[0].Object.CustomKey;
                TableFirstRecordNames[typeof(CounterLogType)] = data[0].Object.Name;
                TableFirstRecordDisplayNames[typeof(CounterLogType)] = data[0].Object.DisplayName;
            }
        }

        [System.Diagnostics.DebuggerStepThrough]
        private async Task InitializeMockSetCounterTypesAsync(Mock<IClarityEcommerceEntities> context, List<Mock<CounterType>> data)
        {
            if (!DoAll && !DoCounters && !DoCounterTypeTable) { return; }
            CounterTypes ??= new Mock<DbSet<CounterType>>();
            await InitializeMockSetFromListAsync(CounterTypes, data).ConfigureAwait(false);
            context.Setup(m => m.CounterTypes).Returns(() => CounterTypes.Object);
            context.Setup(m => m.Set<CounterType>()).Returns(() => CounterTypes.Object);
            TableRecordCounts[typeof(CounterType)] = data.Count;
            if (data.Any())
            {
                TableFirstRecordIDs[typeof(CounterType)] = data[0].Object.ID;
                TableFirstRecordCustomKeys[typeof(CounterType)] = data[0].Object.CustomKey;
                TableFirstRecordNames[typeof(CounterType)] = data[0].Object.Name;
                TableFirstRecordDisplayNames[typeof(CounterType)] = data[0].Object.DisplayName;
            }
        }

        /// <summary>Creates a dummy Counter.</summary>
        /// <returns>The new Counter.</returns>
        [System.Diagnostics.DebuggerStepThrough]
        private Task<Mock<Counter>> CreateADummyCounterAsync(int id, string? key, int typeID = 1, string? jsonAttributes = null, decimal? value = null!, bool? active = null)
        {
            return Task.Run(async () =>
            {
                var mock = new Mock<Counter>();
                mock.SetupAllProperties();
                // IBase Properties
                mock.Object.ID = id;
                mock.Object.CustomKey = key;
                mock.Object.Active = active.HasValue ? active.Value : !DoInactives;
                mock.Object.CreatedDate = CreatedDate;
                mock.Object.UpdatedDate = null;
                mock.Object.Hash = null;
                mock.Object.JsonAttributes = jsonAttributes;
                // IHaveATypeBase Properties
                mock.Object.TypeID = typeID;
                // Counter Properties
                mock.Object.Value = value;
                // Dynamic Linking
                // IHaveATypeBase Properties
                mock.Setup(m => m.Type).Returns(() => RawCounterTypes?.FirstOrDefault(x => x.Object.ID == mock.Object.TypeID)?.Object);
                // Counter's Related Objects
                // Counter's Associated Objects
                mock.Setup(m => m.CounterLogs).Returns(() => RawCounterLogs?.Where(x => x.Object.CounterID == mock.Object.ID).Select(x => x.Object).ToList() ?? new List<CounterLog>());
                return mock;
            });
        }

        /// <summary>Creates a dummy CounterLog.</summary>
        /// <returns>The new CounterLog.</returns>
        [System.Diagnostics.DebuggerStepThrough]
        private Task<Mock<CounterLog>> CreateADummyCounterLogAsync(int id, string? key, int typeID = 1, string? jsonAttributes = null, int counterID = 1, decimal? value = null!, bool? active = null)
        {
            return Task.Run(async () =>
            {
                var mock = new Mock<CounterLog>();
                mock.SetupAllProperties();
                // IBase Properties
                mock.Object.ID = id;
                mock.Object.CustomKey = key;
                mock.Object.Active = active.HasValue ? active.Value : !DoInactives;
                mock.Object.CreatedDate = CreatedDate;
                mock.Object.UpdatedDate = null;
                mock.Object.Hash = null;
                mock.Object.JsonAttributes = jsonAttributes;
                // IHaveATypeBase Properties
                mock.Object.TypeID = typeID;
                // CounterLog Properties
                mock.Object.CounterID = counterID;
                mock.Object.Value = value;
                // Dynamic Linking
                // IHaveATypeBase Properties
                mock.Setup(m => m.Type).Returns(() => RawCounterLogTypes?.FirstOrDefault(x => x.Object.ID == mock.Object.TypeID)?.Object);
                // CounterLog's Related Objects
                mock.Setup(m => m.Counter).Returns(() => RawCounters?.FirstOrDefault(x => x.Object.ID == mock.Object.CounterID)?.Object);
                // CounterLog's Associated Objects
                return mock;
            });
        }

        /// <summary>Creates a dummy CounterLogType.</summary>
        /// <returns>The new CounterLogType.</returns>
        [System.Diagnostics.DebuggerStepThrough]
        private Task<Mock<CounterLogType>> CreateADummyCounterLogTypeAsync(int id, string? key, string? name, string? desc = null, int? sortOrder = null, string? displayName = null, string? translationKey = null, string? jsonAttributes = null, bool? active = null)
        {
            return Task.Run(async () =>
            {
                var mock = new Mock<CounterLogType>();
                mock.SetupAllProperties();
                // IBase Properties
                mock.Object.ID = id;
                mock.Object.CustomKey = key;
                mock.Object.Active = active.HasValue ? active.Value : !DoInactives;
                mock.Object.CreatedDate = CreatedDate;
                mock.Object.UpdatedDate = null;
                mock.Object.Hash = null;
                mock.Object.JsonAttributes = jsonAttributes;
                // INameableBase Properties
                mock.Object.Name = name;
                mock.Object.Description = desc;
                // IDisplayableBase Properties
                mock.Object.SortOrder = sortOrder;
                mock.Object.DisplayName = displayName;
                mock.Object.TranslationKey = translationKey;
                // CounterLogType Properties
                // Dynamic Linking
                // CounterLogType's Related Objects
                // CounterLogType's Associated Objects
                return mock;
            });
        }

        /// <summary>Creates a dummy CounterType.</summary>
        /// <returns>The new CounterType.</returns>
        [System.Diagnostics.DebuggerStepThrough]
        private Task<Mock<CounterType>> CreateADummyCounterTypeAsync(int id, string? key, string? name, string? desc = null, int? sortOrder = null, string? displayName = null, string? translationKey = null, string? jsonAttributes = null, bool? active = null)
        {
            return Task.Run(async () =>
            {
                var mock = new Mock<CounterType>();
                mock.SetupAllProperties();
                // IBase Properties
                mock.Object.ID = id;
                mock.Object.CustomKey = key;
                mock.Object.Active = active.HasValue ? active.Value : !DoInactives;
                mock.Object.CreatedDate = CreatedDate;
                mock.Object.UpdatedDate = null;
                mock.Object.Hash = null;
                mock.Object.JsonAttributes = jsonAttributes;
                // INameableBase Properties
                mock.Object.Name = name;
                mock.Object.Description = desc;
                // IDisplayableBase Properties
                mock.Object.SortOrder = sortOrder;
                mock.Object.DisplayName = displayName;
                mock.Object.TranslationKey = translationKey;
                // CounterType Properties
                // Dynamic Linking
                // CounterType's Related Objects
                // CounterType's Associated Objects
                return mock;
            });
        }
    }
}

namespace Clarity.Ecommerce.DataModel
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Ecommerce.Testing;
    using Interfaces.DataModel;
    using Moq;

    internal partial class DataModelTestingRegistry
    {
        private void CreateRegistryForCounters(MockingSetup mockingSetup)
        {
            Func<Counter> mockFuncCounter = () =>
            {
                var mock = new Mock<Counter>();
                mock.SetupAllProperties();
                mock.Setup(m => m.ToHashableString()).CallBase();
                // Counter Properties
                // Dynamic Linking
                // IHaveATypeBase Properties
                mock.Setup(m => m.Type).Returns(() => mockingSetup.RawCounterTypes?.FirstOrDefault(x => x.Object.ID == mock.Object.TypeID)?.Object);
                // Counter's Associated Objects
                mock.Setup(m => m.CounterLogs).Returns(() => mockingSetup.RawCounterLogs?.Where(x => x.Object.CounterID == mock.Object.ID).Select(x => x.Object).ToList() ?? new List<CounterLog>());
                // Counter's Related Objects
                return mock.Object;
            };
            For<ICounter>().Use(() => mockFuncCounter());
            For<Counter>().Use(() => mockFuncCounter());
            Func<CounterLog> mockFuncCounterLog = () =>
            {
                var mock = new Mock<CounterLog>();
                mock.SetupAllProperties();
                mock.Setup(m => m.ToHashableString()).CallBase();
                // CounterLog Properties
                // Dynamic Linking
                // IHaveATypeBase Properties
                mock.Setup(m => m.Type).Returns(() => mockingSetup.RawCounterLogTypes?.FirstOrDefault(x => x.Object.ID == mock.Object.TypeID)?.Object);
                mock.Setup(m => m.Counter).Returns(() => mockingSetup.RawCounters?.FirstOrDefault(x => x.Object.ID == mock.Object.CounterID)?.Object);
                // CounterLog's Associated Objects
                // CounterLog's Related Objects
                return mock.Object;
            };
            For<ICounterLog>().Use(() => mockFuncCounterLog());
            For<CounterLog>().Use(() => mockFuncCounterLog());
            Func<CounterLogType> mockFuncCounterLogType = () =>
            {
                var mock = new Mock<CounterLogType>();
                mock.SetupAllProperties();
                mock.Setup(m => m.ToHashableString()).CallBase();
                // CounterLogType Properties
                // Dynamic Linking
                // CounterLogType's Associated Objects
                // CounterLogType's Related Objects
                return mock.Object;
            };
            For<ICounterLogType>().Use(() => mockFuncCounterLogType());
            For<CounterLogType>().Use(() => mockFuncCounterLogType());
            Func<CounterType> mockFuncCounterType = () =>
            {
                var mock = new Mock<CounterType>();
                mock.SetupAllProperties();
                mock.Setup(m => m.ToHashableString()).CallBase();
                // CounterType Properties
                // Dynamic Linking
                // CounterType's Associated Objects
                // CounterType's Related Objects
                return mock.Object;
            };
            For<ICounterType>().Use(() => mockFuncCounterType());
            For<CounterType>().Use(() => mockFuncCounterType());
        }
    }
}
