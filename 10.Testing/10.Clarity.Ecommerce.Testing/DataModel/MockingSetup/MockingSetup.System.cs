// <autogenerated>
// <copyright file="System.MockingSetup.cs" company="clarity-ventures.com">
// Copyright (c) 2016-2023 clarity-ventures.com. All rights reserved.
// </copyright>
// <summary>Implements the System section of the Mocking Setup class</summary>
// <remarks>This file was auto-generated by MockingSetupMaster.tt, changes to this
// file will be overwritten automatically when the T4 template is run again</remarks>
// </autogenerated>
// ReSharper disable CyclomaticComplexity, FunctionComplexityOverflow
#pragma warning disable CS0618 // Obsolete Items warnings ignored inside T4
#pragma warning disable CS1998 // Async method lacks 'await' operators and will run synchronously ignored inside T4
#nullable enable
namespace Clarity.Ecommerce.Testing
{
    using System;
    using System.Collections.Generic;
    using System.Data.Entity;
    using System.Linq;
    using System.Threading.Tasks;
    using DataModel;
    using Interfaces.DataModel;
    using Moq;

    public partial class MockingSetup
    {
        // Enable the entire schema on run
        public bool DoSystem { private get; set; }

        // Enable the tables specifically on run
        public bool DoImportExportMappingTable { private get; set; }
        public bool DoNoteTable { private get; set; }
        public bool DoNoteTypeTable { private get; set; }
        public bool DoRecordVersionTable { private get; set; }
        public bool DoRecordVersionTypeTable { private get; set; }
        public bool DoSettingTable { private get; set; }
        public bool DoSettingGroupTable { private get; set; }
        public bool DoSettingTypeTable { private get; set; }
        public bool DoEventLogTable { private get; set; }

        // Dirty Checking
        public bool ImportExportMappingDirty { private get; set; }
        public bool NoteDirty { private get; set; }
        public bool NoteTypeDirty { private get; set; }
        public bool RecordVersionDirty { private get; set; }
        public bool RecordVersionTypeDirty { private get; set; }
        public bool SettingDirty { private get; set; }
        public bool SettingGroupDirty { private get; set; }
        public bool SettingTypeDirty { private get; set; }
        public bool EventLogDirty { private get; set; }

        // Sets
        public Mock<DbSet<ImportExportMapping>>? ImportExportMappings { get; private set; }
        public Mock<DbSet<Note>>? Notes { get; private set; }
        public Mock<DbSet<NoteType>>? NoteTypes { get; private set; }
        public Mock<DbSet<RecordVersion>>? RecordVersions { get; private set; }
        public Mock<DbSet<RecordVersionType>>? RecordVersionTypes { get; private set; }
        public Mock<DbSet<Setting>>? Settings { get; private set; }
        public Mock<DbSet<SettingGroup>>? SettingGroups { get; private set; }
        public Mock<DbSet<SettingType>>? SettingTypes { get; private set; }
        public Mock<DbSet<EventLog>>? EventLogs { get; private set; }

        // Raw Data
        public List<Mock<ImportExportMapping>>? RawImportExportMappings { get; private set; }
        public List<Mock<Note>>? RawNotes { get; private set; }
        public List<Mock<NoteType>>? RawNoteTypes { get; private set; }
        public List<Mock<RecordVersion>>? RawRecordVersions { get; private set; }
        public List<Mock<RecordVersionType>>? RawRecordVersionTypes { get; private set; }
        public List<Mock<Setting>>? RawSettings { get; private set; }
        public List<Mock<SettingGroup>>? RawSettingGroups { get; private set; }
        public List<Mock<SettingType>>? RawSettingTypes { get; private set; }
        public List<Mock<EventLog>>? RawEventLogs { get; private set; }

        [System.Diagnostics.DebuggerStepThrough]
        public async Task AssignSchemaMocksSystemAsync(Mock<IClarityEcommerceEntities> context, bool dirtyOnly)
        {
            if (DoAll || DoSystem || (DoImportExportMappingTable && (!dirtyOnly || ImportExportMappingDirty)))
            {
                var attempts = 0;
                await RetryHelper.RetryOnExceptionAsync(async () =>
                {
                    if (++attempts > 1) { System.Diagnostics.Debug.WriteLine($"Assign Schema Mocks is taking extra attempts: {attempts}"); }
                    if (RawImportExportMappings == null) { throw new InvalidOperationException("Raw ImportExportMappings was null"); }
                    await InitializeMockSetFromListAsync(ImportExportMappings, RawImportExportMappings).ConfigureAwait(false);
                    context.Setup(m => m.ImportExportMappings).Returns(() => ImportExportMappings?.Object!);
                    context.Setup(m => m.Set<ImportExportMapping>()).Returns(() => ImportExportMappings?.Object!);
                })
                .ConfigureAwait(false);
            }
            if (DoAll || DoSystem || (DoNoteTable && (!dirtyOnly || NoteDirty)))
            {
                var attempts = 0;
                await RetryHelper.RetryOnExceptionAsync(async () =>
                {
                    if (++attempts > 1) { System.Diagnostics.Debug.WriteLine($"Assign Schema Mocks is taking extra attempts: {attempts}"); }
                    if (RawNotes == null) { throw new InvalidOperationException("Raw Notes was null"); }
                    await InitializeMockSetFromListAsync(Notes, RawNotes).ConfigureAwait(false);
                    context.Setup(m => m.Notes).Returns(() => Notes?.Object!);
                    context.Setup(m => m.Set<Note>()).Returns(() => Notes?.Object!);
                })
                .ConfigureAwait(false);
            }
            if (DoAll || DoSystem || (DoNoteTypeTable && (!dirtyOnly || NoteTypeDirty)))
            {
                var attempts = 0;
                await RetryHelper.RetryOnExceptionAsync(async () =>
                {
                    if (++attempts > 1) { System.Diagnostics.Debug.WriteLine($"Assign Schema Mocks is taking extra attempts: {attempts}"); }
                    if (RawNoteTypes == null) { throw new InvalidOperationException("Raw NoteTypes was null"); }
                    await InitializeMockSetFromListAsync(NoteTypes, RawNoteTypes).ConfigureAwait(false);
                    context.Setup(m => m.NoteTypes).Returns(() => NoteTypes?.Object!);
                    context.Setup(m => m.Set<NoteType>()).Returns(() => NoteTypes?.Object!);
                })
                .ConfigureAwait(false);
            }
            if (DoAll || DoSystem || (DoRecordVersionTable && (!dirtyOnly || RecordVersionDirty)))
            {
                var attempts = 0;
                await RetryHelper.RetryOnExceptionAsync(async () =>
                {
                    if (++attempts > 1) { System.Diagnostics.Debug.WriteLine($"Assign Schema Mocks is taking extra attempts: {attempts}"); }
                    if (RawRecordVersions == null) { throw new InvalidOperationException("Raw RecordVersions was null"); }
                    await InitializeMockSetFromListAsync(RecordVersions, RawRecordVersions).ConfigureAwait(false);
                    context.Setup(m => m.RecordVersions).Returns(() => RecordVersions?.Object!);
                    context.Setup(m => m.Set<RecordVersion>()).Returns(() => RecordVersions?.Object!);
                })
                .ConfigureAwait(false);
            }
            if (DoAll || DoSystem || (DoRecordVersionTypeTable && (!dirtyOnly || RecordVersionTypeDirty)))
            {
                var attempts = 0;
                await RetryHelper.RetryOnExceptionAsync(async () =>
                {
                    if (++attempts > 1) { System.Diagnostics.Debug.WriteLine($"Assign Schema Mocks is taking extra attempts: {attempts}"); }
                    if (RawRecordVersionTypes == null) { throw new InvalidOperationException("Raw RecordVersionTypes was null"); }
                    await InitializeMockSetFromListAsync(RecordVersionTypes, RawRecordVersionTypes).ConfigureAwait(false);
                    context.Setup(m => m.RecordVersionTypes).Returns(() => RecordVersionTypes?.Object!);
                    context.Setup(m => m.Set<RecordVersionType>()).Returns(() => RecordVersionTypes?.Object!);
                })
                .ConfigureAwait(false);
            }
            if (DoAll || DoSystem || (DoSettingTable && (!dirtyOnly || SettingDirty)))
            {
                var attempts = 0;
                await RetryHelper.RetryOnExceptionAsync(async () =>
                {
                    if (++attempts > 1) { System.Diagnostics.Debug.WriteLine($"Assign Schema Mocks is taking extra attempts: {attempts}"); }
                    if (RawSettings == null) { throw new InvalidOperationException("Raw Settings was null"); }
                    await InitializeMockSetFromListAsync(Settings, RawSettings).ConfigureAwait(false);
                    context.Setup(m => m.Settings).Returns(() => Settings?.Object!);
                    context.Setup(m => m.Set<Setting>()).Returns(() => Settings?.Object!);
                })
                .ConfigureAwait(false);
            }
            if (DoAll || DoSystem || (DoSettingGroupTable && (!dirtyOnly || SettingGroupDirty)))
            {
                var attempts = 0;
                await RetryHelper.RetryOnExceptionAsync(async () =>
                {
                    if (++attempts > 1) { System.Diagnostics.Debug.WriteLine($"Assign Schema Mocks is taking extra attempts: {attempts}"); }
                    if (RawSettingGroups == null) { throw new InvalidOperationException("Raw SettingGroups was null"); }
                    await InitializeMockSetFromListAsync(SettingGroups, RawSettingGroups).ConfigureAwait(false);
                    context.Setup(m => m.SettingGroups).Returns(() => SettingGroups?.Object!);
                    context.Setup(m => m.Set<SettingGroup>()).Returns(() => SettingGroups?.Object!);
                })
                .ConfigureAwait(false);
            }
            if (DoAll || DoSystem || (DoSettingTypeTable && (!dirtyOnly || SettingTypeDirty)))
            {
                var attempts = 0;
                await RetryHelper.RetryOnExceptionAsync(async () =>
                {
                    if (++attempts > 1) { System.Diagnostics.Debug.WriteLine($"Assign Schema Mocks is taking extra attempts: {attempts}"); }
                    if (RawSettingTypes == null) { throw new InvalidOperationException("Raw SettingTypes was null"); }
                    await InitializeMockSetFromListAsync(SettingTypes, RawSettingTypes).ConfigureAwait(false);
                    context.Setup(m => m.SettingTypes).Returns(() => SettingTypes?.Object!);
                    context.Setup(m => m.Set<SettingType>()).Returns(() => SettingTypes?.Object!);
                })
                .ConfigureAwait(false);
            }
            if (DoAll || DoSystem || (DoEventLogTable && (!dirtyOnly || EventLogDirty)))
            {
                var attempts = 0;
                await RetryHelper.RetryOnExceptionAsync(async () =>
                {
                    if (++attempts > 1) { System.Diagnostics.Debug.WriteLine($"Assign Schema Mocks is taking extra attempts: {attempts}"); }
                    if (RawEventLogs == null) { throw new InvalidOperationException("Raw EventLogs was null"); }
                    await InitializeMockSetFromListAsync(EventLogs, RawEventLogs).ConfigureAwait(false);
                    context.Setup(m => m.EventLogs).Returns(() => EventLogs?.Object!);
                    context.Setup(m => m.Set<EventLog>()).Returns(() => EventLogs?.Object!);
                })
                .ConfigureAwait(false);
            }
        }

        [System.Diagnostics.DebuggerStepThrough]
        private async Task InitializeMockSetImportExportMappingsAsync(Mock<IClarityEcommerceEntities> context, List<Mock<ImportExportMapping>> data)
        {
            if (!DoAll && !DoSystem && !DoImportExportMappingTable) { return; }
            ImportExportMappings ??= new Mock<DbSet<ImportExportMapping>>();
            await InitializeMockSetFromListAsync(ImportExportMappings, data).ConfigureAwait(false);
            context.Setup(m => m.ImportExportMappings).Returns(() => ImportExportMappings.Object);
            context.Setup(m => m.Set<ImportExportMapping>()).Returns(() => ImportExportMappings.Object);
            TableRecordCounts[typeof(ImportExportMapping)] = data.Count;
            if (data.Any())
            {
                TableFirstRecordIDs[typeof(ImportExportMapping)] = data[0].Object.ID;
                TableFirstRecordCustomKeys[typeof(ImportExportMapping)] = data[0].Object.CustomKey;
                TableFirstRecordNames[typeof(ImportExportMapping)] = data[0].Object.Name;
            }
        }

        [System.Diagnostics.DebuggerStepThrough]
        private async Task InitializeMockSetNotesAsync(Mock<IClarityEcommerceEntities> context, List<Mock<Note>> data)
        {
            if (!DoAll && !DoSystem && !DoNoteTable) { return; }
            Notes ??= new Mock<DbSet<Note>>();
            await InitializeMockSetFromListAsync(Notes, data).ConfigureAwait(false);
            context.Setup(m => m.Notes).Returns(() => Notes.Object);
            context.Setup(m => m.Set<Note>()).Returns(() => Notes.Object);
            TableRecordCounts[typeof(Note)] = data.Count;
            if (data.Any())
            {
                TableFirstRecordIDs[typeof(Note)] = data[0].Object.ID;
                TableFirstRecordCustomKeys[typeof(Note)] = data[0].Object.CustomKey;
            }
        }

        [System.Diagnostics.DebuggerStepThrough]
        private async Task InitializeMockSetNoteTypesAsync(Mock<IClarityEcommerceEntities> context, List<Mock<NoteType>> data)
        {
            if (!DoAll && !DoSystem && !DoNoteTypeTable) { return; }
            NoteTypes ??= new Mock<DbSet<NoteType>>();
            await InitializeMockSetFromListAsync(NoteTypes, data).ConfigureAwait(false);
            context.Setup(m => m.NoteTypes).Returns(() => NoteTypes.Object);
            context.Setup(m => m.Set<NoteType>()).Returns(() => NoteTypes.Object);
            TableRecordCounts[typeof(NoteType)] = data.Count;
            if (data.Any())
            {
                TableFirstRecordIDs[typeof(NoteType)] = data[0].Object.ID;
                TableFirstRecordCustomKeys[typeof(NoteType)] = data[0].Object.CustomKey;
                TableFirstRecordNames[typeof(NoteType)] = data[0].Object.Name;
                TableFirstRecordDisplayNames[typeof(NoteType)] = data[0].Object.DisplayName;
            }
        }

        [System.Diagnostics.DebuggerStepThrough]
        private async Task InitializeMockSetRecordVersionsAsync(Mock<IClarityEcommerceEntities> context, List<Mock<RecordVersion>> data)
        {
            if (!DoAll && !DoSystem && !DoRecordVersionTable) { return; }
            RecordVersions ??= new Mock<DbSet<RecordVersion>>();
            await InitializeMockSetFromListAsync(RecordVersions, data).ConfigureAwait(false);
            context.Setup(m => m.RecordVersions).Returns(() => RecordVersions.Object);
            context.Setup(m => m.Set<RecordVersion>()).Returns(() => RecordVersions.Object);
            TableRecordCounts[typeof(RecordVersion)] = data.Count;
            if (data.Any())
            {
                TableFirstRecordIDs[typeof(RecordVersion)] = data[0].Object.ID;
                TableFirstRecordCustomKeys[typeof(RecordVersion)] = data[0].Object.CustomKey;
                TableFirstRecordNames[typeof(RecordVersion)] = data[0].Object.Name;
            }
        }

        [System.Diagnostics.DebuggerStepThrough]
        private async Task InitializeMockSetRecordVersionTypesAsync(Mock<IClarityEcommerceEntities> context, List<Mock<RecordVersionType>> data)
        {
            if (!DoAll && !DoSystem && !DoRecordVersionTypeTable) { return; }
            RecordVersionTypes ??= new Mock<DbSet<RecordVersionType>>();
            await InitializeMockSetFromListAsync(RecordVersionTypes, data).ConfigureAwait(false);
            context.Setup(m => m.RecordVersionTypes).Returns(() => RecordVersionTypes.Object);
            context.Setup(m => m.Set<RecordVersionType>()).Returns(() => RecordVersionTypes.Object);
            TableRecordCounts[typeof(RecordVersionType)] = data.Count;
            if (data.Any())
            {
                TableFirstRecordIDs[typeof(RecordVersionType)] = data[0].Object.ID;
                TableFirstRecordCustomKeys[typeof(RecordVersionType)] = data[0].Object.CustomKey;
                TableFirstRecordNames[typeof(RecordVersionType)] = data[0].Object.Name;
                TableFirstRecordDisplayNames[typeof(RecordVersionType)] = data[0].Object.DisplayName;
            }
        }

        [System.Diagnostics.DebuggerStepThrough]
        private async Task InitializeMockSetSettingsAsync(Mock<IClarityEcommerceEntities> context, List<Mock<Setting>> data)
        {
            if (!DoAll && !DoSystem && !DoSettingTable) { return; }
            Settings ??= new Mock<DbSet<Setting>>();
            await InitializeMockSetFromListAsync(Settings, data).ConfigureAwait(false);
            context.Setup(m => m.Settings).Returns(() => Settings.Object);
            context.Setup(m => m.Set<Setting>()).Returns(() => Settings.Object);
            TableRecordCounts[typeof(Setting)] = data.Count;
            if (data.Any())
            {
                TableFirstRecordIDs[typeof(Setting)] = data[0].Object.ID;
                TableFirstRecordCustomKeys[typeof(Setting)] = data[0].Object.CustomKey;
            }
        }

        [System.Diagnostics.DebuggerStepThrough]
        private async Task InitializeMockSetSettingGroupsAsync(Mock<IClarityEcommerceEntities> context, List<Mock<SettingGroup>> data)
        {
            if (!DoAll && !DoSystem && !DoSettingGroupTable) { return; }
            SettingGroups ??= new Mock<DbSet<SettingGroup>>();
            await InitializeMockSetFromListAsync(SettingGroups, data).ConfigureAwait(false);
            context.Setup(m => m.SettingGroups).Returns(() => SettingGroups.Object);
            context.Setup(m => m.Set<SettingGroup>()).Returns(() => SettingGroups.Object);
            TableRecordCounts[typeof(SettingGroup)] = data.Count;
            if (data.Any())
            {
                TableFirstRecordIDs[typeof(SettingGroup)] = data[0].Object.ID;
                TableFirstRecordCustomKeys[typeof(SettingGroup)] = data[0].Object.CustomKey;
                TableFirstRecordNames[typeof(SettingGroup)] = data[0].Object.Name;
                TableFirstRecordDisplayNames[typeof(SettingGroup)] = data[0].Object.DisplayName;
            }
        }

        [System.Diagnostics.DebuggerStepThrough]
        private async Task InitializeMockSetSettingTypesAsync(Mock<IClarityEcommerceEntities> context, List<Mock<SettingType>> data)
        {
            if (!DoAll && !DoSystem && !DoSettingTypeTable) { return; }
            SettingTypes ??= new Mock<DbSet<SettingType>>();
            await InitializeMockSetFromListAsync(SettingTypes, data).ConfigureAwait(false);
            context.Setup(m => m.SettingTypes).Returns(() => SettingTypes.Object);
            context.Setup(m => m.Set<SettingType>()).Returns(() => SettingTypes.Object);
            TableRecordCounts[typeof(SettingType)] = data.Count;
            if (data.Any())
            {
                TableFirstRecordIDs[typeof(SettingType)] = data[0].Object.ID;
                TableFirstRecordCustomKeys[typeof(SettingType)] = data[0].Object.CustomKey;
                TableFirstRecordNames[typeof(SettingType)] = data[0].Object.Name;
                TableFirstRecordDisplayNames[typeof(SettingType)] = data[0].Object.DisplayName;
            }
        }

        [System.Diagnostics.DebuggerStepThrough]
        private async Task InitializeMockSetEventLogsAsync(Mock<IClarityEcommerceEntities> context, List<Mock<EventLog>> data)
        {
            if (!DoAll && !DoSystem && !DoEventLogTable) { return; }
            EventLogs ??= new Mock<DbSet<EventLog>>();
            await InitializeMockSetFromListAsync(EventLogs, data).ConfigureAwait(false);
            context.Setup(m => m.EventLogs).Returns(() => EventLogs.Object);
            context.Setup(m => m.Set<EventLog>()).Returns(() => EventLogs.Object);
            TableRecordCounts[typeof(EventLog)] = data.Count;
            if (data.Any())
            {
                TableFirstRecordIDs[typeof(EventLog)] = data[0].Object.ID;
                TableFirstRecordCustomKeys[typeof(EventLog)] = data[0].Object.CustomKey;
                TableFirstRecordNames[typeof(EventLog)] = data[0].Object.Name;
            }
        }

        /// <summary>Creates a dummy ImportExportMapping.</summary>
        /// <returns>The new ImportExportMapping.</returns>
        [System.Diagnostics.DebuggerStepThrough]
        private Task<Mock<ImportExportMapping>> CreateADummyImportExportMappingAsync(int id, string? key, string? name, string? desc = null, string? jsonAttributes = null, string mappingJson = null!, long? mappingJsonHash = null!, bool? active = null)
        {
            return Task.Run(async () =>
            {
                var mock = new Mock<ImportExportMapping>();
                mock.SetupAllProperties();
                // IBase Properties
                mock.Object.ID = id;
                mock.Object.CustomKey = key;
                mock.Object.Active = active.HasValue ? active.Value : !DoInactives;
                mock.Object.CreatedDate = CreatedDate;
                mock.Object.UpdatedDate = null;
                mock.Object.Hash = null;
                mock.Object.JsonAttributes = jsonAttributes;
                // INameableBase Properties
                mock.Object.Name = name;
                mock.Object.Description = desc;
                // ImportExportMapping Properties
                mock.Object.MappingJson = mappingJson;
                mock.Object.MappingJsonHash = mappingJsonHash;
                // Dynamic Linking
                // ImportExportMapping's Related Objects
                // ImportExportMapping's Associated Objects
                return mock;
            });
        }

        /// <summary>Creates a dummy Note.</summary>
        /// <returns>The new Note.</returns>
        [System.Diagnostics.DebuggerStepThrough]
        private Task<Mock<Note>> CreateADummyNoteAsync(int id, string? key, int typeID = 1, string? jsonAttributes = null, int? accountID = null!, int? brandID = null!, int? cartID = null!, int? cartItemID = null!, int? createdByUserID = null!, int? franchiseID = null!, int? manufacturerID = null!, string note1 = null!, int? purchaseOrderID = null!, int? purchaseOrderItemID = null!, int? salesGroupID = null!, int? salesInvoiceID = null!, int? salesInvoiceItemID = null!, int? salesOrderID = null!, int? salesOrderItemID = null!, int? salesQuoteID = null!, int? salesQuoteItemID = null!, int? salesReturnID = null!, int? salesReturnItemID = null!, int? sampleRequestID = null!, int? sampleRequestItemID = null!, int? storeID = null!, int? updatedByUserID = null!, int? userID = null!, int? vendorID = null!, bool? active = null)
        {
            return Task.Run(async () =>
            {
                var mock = new Mock<Note>();
                mock.SetupAllProperties();
                // IBase Properties
                mock.Object.ID = id;
                mock.Object.CustomKey = key;
                mock.Object.Active = active.HasValue ? active.Value : !DoInactives;
                mock.Object.CreatedDate = CreatedDate;
                mock.Object.UpdatedDate = null;
                mock.Object.Hash = null;
                mock.Object.JsonAttributes = jsonAttributes;
                // IHaveATypeBase Properties
                mock.Object.TypeID = typeID;
                // Note Properties
                mock.Object.AccountID = accountID;
                mock.Object.BrandID = brandID;
                mock.Object.CartID = cartID;
                mock.Object.CartItemID = cartItemID;
                mock.Object.CreatedByUserID = createdByUserID;
                mock.Object.FranchiseID = franchiseID;
                mock.Object.ManufacturerID = manufacturerID;
                mock.Object.Note1 = note1;
                mock.Object.PurchaseOrderID = purchaseOrderID;
                mock.Object.PurchaseOrderItemID = purchaseOrderItemID;
                mock.Object.SalesGroupID = salesGroupID;
                mock.Object.SalesInvoiceID = salesInvoiceID;
                mock.Object.SalesInvoiceItemID = salesInvoiceItemID;
                mock.Object.SalesOrderID = salesOrderID;
                mock.Object.SalesOrderItemID = salesOrderItemID;
                mock.Object.SalesQuoteID = salesQuoteID;
                mock.Object.SalesQuoteItemID = salesQuoteItemID;
                mock.Object.SalesReturnID = salesReturnID;
                mock.Object.SalesReturnItemID = salesReturnItemID;
                mock.Object.SampleRequestID = sampleRequestID;
                mock.Object.SampleRequestItemID = sampleRequestItemID;
                mock.Object.StoreID = storeID;
                mock.Object.UpdatedByUserID = updatedByUserID;
                mock.Object.UserID = userID;
                mock.Object.VendorID = vendorID;
                // Dynamic Linking
                // IHaveATypeBase Properties
                mock.Setup(m => m.Type).Returns(() => RawNoteTypes?.FirstOrDefault(x => x.Object.ID == mock.Object.TypeID)?.Object);
                // Note's Related Objects
                mock.Setup(m => m.Account).Returns(() => RawAccounts?.FirstOrDefault(x => x.Object.ID == mock.Object.AccountID)?.Object);
                mock.Setup(m => m.Brand).Returns(() => RawBrands?.FirstOrDefault(x => x.Object.ID == mock.Object.BrandID)?.Object);
                mock.Setup(m => m.Cart).Returns(() => RawCarts?.FirstOrDefault(x => x.Object.ID == mock.Object.CartID)?.Object);
                mock.Setup(m => m.CartItem).Returns(() => RawCartItems?.FirstOrDefault(x => x.Object.ID == mock.Object.CartItemID)?.Object);
                mock.Setup(m => m.CreatedByUser).Returns(() => RawUsers?.FirstOrDefault(x => x.Object.ID == mock.Object.CreatedByUserID)?.Object);
                mock.Setup(m => m.Franchise).Returns(() => RawFranchises?.FirstOrDefault(x => x.Object.ID == mock.Object.FranchiseID)?.Object);
                mock.Setup(m => m.Manufacturer).Returns(() => RawManufacturers?.FirstOrDefault(x => x.Object.ID == mock.Object.ManufacturerID)?.Object);
                mock.Setup(m => m.PurchaseOrder).Returns(() => RawPurchaseOrders?.FirstOrDefault(x => x.Object.ID == mock.Object.PurchaseOrderID)?.Object);
                mock.Setup(m => m.PurchaseOrderItem).Returns(() => RawPurchaseOrderItems?.FirstOrDefault(x => x.Object.ID == mock.Object.PurchaseOrderItemID)?.Object);
                mock.Setup(m => m.SalesGroup).Returns(() => RawSalesGroups?.FirstOrDefault(x => x.Object.ID == mock.Object.SalesGroupID)?.Object);
                mock.Setup(m => m.SalesInvoice).Returns(() => RawSalesInvoices?.FirstOrDefault(x => x.Object.ID == mock.Object.SalesInvoiceID)?.Object);
                mock.Setup(m => m.SalesInvoiceItem).Returns(() => RawSalesInvoiceItems?.FirstOrDefault(x => x.Object.ID == mock.Object.SalesInvoiceItemID)?.Object);
                mock.Setup(m => m.SalesOrder).Returns(() => RawSalesOrders?.FirstOrDefault(x => x.Object.ID == mock.Object.SalesOrderID)?.Object);
                mock.Setup(m => m.SalesOrderItem).Returns(() => RawSalesOrderItems?.FirstOrDefault(x => x.Object.ID == mock.Object.SalesOrderItemID)?.Object);
                mock.Setup(m => m.SalesQuote).Returns(() => RawSalesQuotes?.FirstOrDefault(x => x.Object.ID == mock.Object.SalesQuoteID)?.Object);
                mock.Setup(m => m.SalesQuoteItem).Returns(() => RawSalesQuoteItems?.FirstOrDefault(x => x.Object.ID == mock.Object.SalesQuoteItemID)?.Object);
                mock.Setup(m => m.SalesReturn).Returns(() => RawSalesReturns?.FirstOrDefault(x => x.Object.ID == mock.Object.SalesReturnID)?.Object);
                mock.Setup(m => m.SalesReturnItem).Returns(() => RawSalesReturnItems?.FirstOrDefault(x => x.Object.ID == mock.Object.SalesReturnItemID)?.Object);
                mock.Setup(m => m.SampleRequest).Returns(() => RawSampleRequests?.FirstOrDefault(x => x.Object.ID == mock.Object.SampleRequestID)?.Object);
                mock.Setup(m => m.SampleRequestItem).Returns(() => RawSampleRequestItems?.FirstOrDefault(x => x.Object.ID == mock.Object.SampleRequestItemID)?.Object);
                mock.Setup(m => m.Store).Returns(() => RawStores?.FirstOrDefault(x => x.Object.ID == mock.Object.StoreID)?.Object);
                mock.Setup(m => m.UpdatedByUser).Returns(() => RawUsers?.FirstOrDefault(x => x.Object.ID == mock.Object.UpdatedByUserID)?.Object);
                mock.Setup(m => m.User).Returns(() => RawUsers?.FirstOrDefault(x => x.Object.ID == mock.Object.UserID)?.Object);
                mock.Setup(m => m.Vendor).Returns(() => RawVendors?.FirstOrDefault(x => x.Object.ID == mock.Object.VendorID)?.Object);
                // Note's Associated Objects
                return mock;
            });
        }

        /// <summary>Creates a dummy NoteType.</summary>
        /// <returns>The new NoteType.</returns>
        [System.Diagnostics.DebuggerStepThrough]
        private Task<Mock<NoteType>> CreateADummyNoteTypeAsync(int id, string? key, string? name, string? desc = null, int? sortOrder = null, string? displayName = null, string? translationKey = null, string? jsonAttributes = null, bool isCustomer = false, bool isPublic = false, bool? active = null)
        {
            return Task.Run(async () =>
            {
                var mock = new Mock<NoteType>();
                mock.SetupAllProperties();
                // IBase Properties
                mock.Object.ID = id;
                mock.Object.CustomKey = key;
                mock.Object.Active = active.HasValue ? active.Value : !DoInactives;
                mock.Object.CreatedDate = CreatedDate;
                mock.Object.UpdatedDate = null;
                mock.Object.Hash = null;
                mock.Object.JsonAttributes = jsonAttributes;
                // INameableBase Properties
                mock.Object.Name = name;
                mock.Object.Description = desc;
                // IDisplayableBase Properties
                mock.Object.SortOrder = sortOrder;
                mock.Object.DisplayName = displayName;
                mock.Object.TranslationKey = translationKey;
                // NoteType Properties
                mock.Object.IsCustomer = isCustomer;
                mock.Object.IsPublic = isPublic;
                // Dynamic Linking
                // NoteType's Related Objects
                // NoteType's Associated Objects
                return mock;
            });
        }

        /// <summary>Creates a dummy RecordVersion.</summary>
        /// <returns>The new RecordVersion.</returns>
        [System.Diagnostics.DebuggerStepThrough]
        private Task<Mock<RecordVersion>> CreateADummyRecordVersionAsync(int id, string? key, string? name, string? desc = null, int typeID = 1, string? jsonAttributes = null, int? brandID = null!, bool isDraft = false, DateTime? mostRecentPublishDate = null!, DateTime? originalPublishDate = null!, int? publishedByUserID = null!, int? recordID = null!, string serializedRecord = null!, int? storeID = null!, bool? active = null)
        {
            return Task.Run(async () =>
            {
                var mock = new Mock<RecordVersion>();
                mock.SetupAllProperties();
                // IBase Properties
                mock.Object.ID = id;
                mock.Object.CustomKey = key;
                mock.Object.Active = active.HasValue ? active.Value : !DoInactives;
                mock.Object.CreatedDate = CreatedDate;
                mock.Object.UpdatedDate = null;
                mock.Object.Hash = null;
                mock.Object.JsonAttributes = jsonAttributes;
                // INameableBase Properties
                mock.Object.Name = name;
                mock.Object.Description = desc;
                // IHaveATypeBase Properties
                mock.Object.TypeID = typeID;
                // RecordVersion Properties
                mock.Object.BrandID = brandID;
                mock.Object.IsDraft = isDraft;
                mock.Object.MostRecentPublishDate = mostRecentPublishDate;
                mock.Object.OriginalPublishDate = originalPublishDate;
                mock.Object.PublishedByUserID = publishedByUserID;
                mock.Object.RecordID = recordID;
                mock.Object.SerializedRecord = serializedRecord;
                mock.Object.StoreID = storeID;
                // Dynamic Linking
                // IHaveATypeBase Properties
                mock.Setup(m => m.Type).Returns(() => RawRecordVersionTypes?.FirstOrDefault(x => x.Object.ID == mock.Object.TypeID)?.Object);
                // RecordVersion's Related Objects
                mock.Setup(m => m.Brand).Returns(() => RawBrands?.FirstOrDefault(x => x.Object.ID == mock.Object.BrandID)?.Object);
                mock.Setup(m => m.PublishedByUser).Returns(() => RawUsers?.FirstOrDefault(x => x.Object.ID == mock.Object.PublishedByUserID)?.Object);
                mock.Setup(m => m.Store).Returns(() => RawStores?.FirstOrDefault(x => x.Object.ID == mock.Object.StoreID)?.Object);
                // RecordVersion's Associated Objects
                return mock;
            });
        }

        /// <summary>Creates a dummy RecordVersionType.</summary>
        /// <returns>The new RecordVersionType.</returns>
        [System.Diagnostics.DebuggerStepThrough]
        private Task<Mock<RecordVersionType>> CreateADummyRecordVersionTypeAsync(int id, string? key, string? name, string? desc = null, int? sortOrder = null, string? displayName = null, string? translationKey = null, string? jsonAttributes = null, bool? active = null)
        {
            return Task.Run(async () =>
            {
                var mock = new Mock<RecordVersionType>();
                mock.SetupAllProperties();
                // IBase Properties
                mock.Object.ID = id;
                mock.Object.CustomKey = key;
                mock.Object.Active = active.HasValue ? active.Value : !DoInactives;
                mock.Object.CreatedDate = CreatedDate;
                mock.Object.UpdatedDate = null;
                mock.Object.Hash = null;
                mock.Object.JsonAttributes = jsonAttributes;
                // INameableBase Properties
                mock.Object.Name = name;
                mock.Object.Description = desc;
                // IDisplayableBase Properties
                mock.Object.SortOrder = sortOrder;
                mock.Object.DisplayName = displayName;
                mock.Object.TranslationKey = translationKey;
                // RecordVersionType Properties
                // Dynamic Linking
                // RecordVersionType's Related Objects
                // RecordVersionType's Associated Objects
                return mock;
            });
        }

        /// <summary>Creates a dummy Setting.</summary>
        /// <returns>The new Setting.</returns>
        [System.Diagnostics.DebuggerStepThrough]
        private Task<Mock<Setting>> CreateADummySettingAsync(int id, string? key, int typeID = 1, string? jsonAttributes = null, int? brandID = null!, int? settingGroupID = null!, int? storeID = null!, string value = null!, bool? active = null)
        {
            return Task.Run(async () =>
            {
                var mock = new Mock<Setting>();
                mock.SetupAllProperties();
                // IBase Properties
                mock.Object.ID = id;
                mock.Object.CustomKey = key;
                mock.Object.Active = active.HasValue ? active.Value : !DoInactives;
                mock.Object.CreatedDate = CreatedDate;
                mock.Object.UpdatedDate = null;
                mock.Object.Hash = null;
                mock.Object.JsonAttributes = jsonAttributes;
                // IHaveATypeBase Properties
                mock.Object.TypeID = typeID;
                // Setting Properties
                mock.Object.BrandID = brandID;
                mock.Object.SettingGroupID = settingGroupID;
                mock.Object.StoreID = storeID;
                mock.Object.Value = value;
                // Dynamic Linking
                // IHaveATypeBase Properties
                mock.Setup(m => m.Type).Returns(() => RawSettingTypes?.FirstOrDefault(x => x.Object.ID == mock.Object.TypeID)?.Object);
                // Setting's Related Objects
                mock.Setup(m => m.Brand).Returns(() => RawBrands?.FirstOrDefault(x => x.Object.ID == mock.Object.BrandID)?.Object);
                mock.Setup(m => m.SettingGroup).Returns(() => RawSettingGroups?.FirstOrDefault(x => x.Object.ID == mock.Object.SettingGroupID)?.Object);
                mock.Setup(m => m.Store).Returns(() => RawStores?.FirstOrDefault(x => x.Object.ID == mock.Object.StoreID)?.Object);
                // Setting's Associated Objects
                return mock;
            });
        }

        /// <summary>Creates a dummy SettingGroup.</summary>
        /// <returns>The new SettingGroup.</returns>
        [System.Diagnostics.DebuggerStepThrough]
        private Task<Mock<SettingGroup>> CreateADummySettingGroupAsync(int id, string? key, string? name, string? desc = null, int? sortOrder = null, string? displayName = null, string? translationKey = null, string? jsonAttributes = null, bool? active = null)
        {
            return Task.Run(async () =>
            {
                var mock = new Mock<SettingGroup>();
                mock.SetupAllProperties();
                // IBase Properties
                mock.Object.ID = id;
                mock.Object.CustomKey = key;
                mock.Object.Active = active.HasValue ? active.Value : !DoInactives;
                mock.Object.CreatedDate = CreatedDate;
                mock.Object.UpdatedDate = null;
                mock.Object.Hash = null;
                mock.Object.JsonAttributes = jsonAttributes;
                // INameableBase Properties
                mock.Object.Name = name;
                mock.Object.Description = desc;
                // IDisplayableBase Properties
                mock.Object.SortOrder = sortOrder;
                mock.Object.DisplayName = displayName;
                mock.Object.TranslationKey = translationKey;
                // SettingGroup Properties
                // Dynamic Linking
                // SettingGroup's Related Objects
                // SettingGroup's Associated Objects
                return mock;
            });
        }

        /// <summary>Creates a dummy SettingType.</summary>
        /// <returns>The new SettingType.</returns>
        [System.Diagnostics.DebuggerStepThrough]
        private Task<Mock<SettingType>> CreateADummySettingTypeAsync(int id, string? key, string? name, string? desc = null, int? sortOrder = null, string? displayName = null, string? translationKey = null, string? jsonAttributes = null, bool? active = null)
        {
            return Task.Run(async () =>
            {
                var mock = new Mock<SettingType>();
                mock.SetupAllProperties();
                // IBase Properties
                mock.Object.ID = id;
                mock.Object.CustomKey = key;
                mock.Object.Active = active.HasValue ? active.Value : !DoInactives;
                mock.Object.CreatedDate = CreatedDate;
                mock.Object.UpdatedDate = null;
                mock.Object.Hash = null;
                mock.Object.JsonAttributes = jsonAttributes;
                // INameableBase Properties
                mock.Object.Name = name;
                mock.Object.Description = desc;
                // IDisplayableBase Properties
                mock.Object.SortOrder = sortOrder;
                mock.Object.DisplayName = displayName;
                mock.Object.TranslationKey = translationKey;
                // SettingType Properties
                // Dynamic Linking
                // SettingType's Related Objects
                // SettingType's Associated Objects
                return mock;
            });
        }

        /// <summary>Creates a dummy EventLog.</summary>
        /// <returns>The new EventLog.</returns>
        [System.Diagnostics.DebuggerStepThrough]
        private Task<Mock<EventLog>> CreateADummyEventLogAsync(int id, string? key, string? name, string? desc = null, string? jsonAttributes = null, int? brandID = null!, int? dataID = null!, int? logLevel = null!, int? storeID = null!, bool? active = null)
        {
            return Task.Run(async () =>
            {
                var mock = new Mock<EventLog>();
                mock.SetupAllProperties();
                // IBase Properties
                mock.Object.ID = id;
                mock.Object.CustomKey = key;
                mock.Object.Active = active.HasValue ? active.Value : !DoInactives;
                mock.Object.CreatedDate = CreatedDate;
                mock.Object.UpdatedDate = null;
                mock.Object.Hash = null;
                mock.Object.JsonAttributes = jsonAttributes;
                // INameableBase Properties
                mock.Object.Name = name;
                mock.Object.Description = desc;
                // EventLog Properties
                mock.Object.BrandID = brandID;
                mock.Object.DataID = dataID;
                mock.Object.LogLevel = logLevel;
                mock.Object.StoreID = storeID;
                // Dynamic Linking
                // EventLog's Related Objects
                mock.Setup(m => m.Brand).Returns(() => RawBrands?.FirstOrDefault(x => x.Object.ID == mock.Object.BrandID)?.Object);
                mock.Setup(m => m.Store).Returns(() => RawStores?.FirstOrDefault(x => x.Object.ID == mock.Object.StoreID)?.Object);
                // EventLog's Associated Objects
                return mock;
            });
        }
    }
}

namespace Clarity.Ecommerce.DataModel
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Ecommerce.Testing;
    using Interfaces.DataModel;
    using Moq;

    internal partial class DataModelTestingRegistry
    {
        private void CreateRegistryForSystem(MockingSetup mockingSetup)
        {
            Func<ImportExportMapping> mockFuncImportExportMapping = () =>
            {
                var mock = new Mock<ImportExportMapping>();
                mock.SetupAllProperties();
                mock.Setup(m => m.ToHashableString()).CallBase();
                // ImportExportMapping Properties
                // Dynamic Linking
                // ImportExportMapping's Associated Objects
                // ImportExportMapping's Related Objects
                return mock.Object;
            };
            For<IImportExportMapping>().Use(() => mockFuncImportExportMapping());
            For<ImportExportMapping>().Use(() => mockFuncImportExportMapping());
            Func<Note> mockFuncNote = () =>
            {
                var mock = new Mock<Note>();
                mock.SetupAllProperties();
                mock.Setup(m => m.ToHashableString()).CallBase();
                // Note Properties
                // Dynamic Linking
                // IHaveATypeBase Properties
                mock.Setup(m => m.Type).Returns(() => mockingSetup.RawNoteTypes?.FirstOrDefault(x => x.Object.ID == mock.Object.TypeID)?.Object);
                mock.Setup(m => m.Account).Returns(() => mockingSetup.RawAccounts?.FirstOrDefault(x => x.Object.ID == mock.Object.AccountID)?.Object);
                mock.Setup(m => m.Brand).Returns(() => mockingSetup.RawBrands?.FirstOrDefault(x => x.Object.ID == mock.Object.BrandID)?.Object);
                mock.Setup(m => m.Cart).Returns(() => mockingSetup.RawCarts?.FirstOrDefault(x => x.Object.ID == mock.Object.CartID)?.Object);
                mock.Setup(m => m.CartItem).Returns(() => mockingSetup.RawCartItems?.FirstOrDefault(x => x.Object.ID == mock.Object.CartItemID)?.Object);
                mock.Setup(m => m.CreatedByUser).Returns(() => mockingSetup.RawUsers?.FirstOrDefault(x => x.Object.ID == mock.Object.CreatedByUserID)?.Object);
                mock.Setup(m => m.Franchise).Returns(() => mockingSetup.RawFranchises?.FirstOrDefault(x => x.Object.ID == mock.Object.FranchiseID)?.Object);
                mock.Setup(m => m.Manufacturer).Returns(() => mockingSetup.RawManufacturers?.FirstOrDefault(x => x.Object.ID == mock.Object.ManufacturerID)?.Object);
                mock.Setup(m => m.PurchaseOrder).Returns(() => mockingSetup.RawPurchaseOrders?.FirstOrDefault(x => x.Object.ID == mock.Object.PurchaseOrderID)?.Object);
                mock.Setup(m => m.PurchaseOrderItem).Returns(() => mockingSetup.RawPurchaseOrderItems?.FirstOrDefault(x => x.Object.ID == mock.Object.PurchaseOrderItemID)?.Object);
                mock.Setup(m => m.SalesGroup).Returns(() => mockingSetup.RawSalesGroups?.FirstOrDefault(x => x.Object.ID == mock.Object.SalesGroupID)?.Object);
                mock.Setup(m => m.SalesInvoice).Returns(() => mockingSetup.RawSalesInvoices?.FirstOrDefault(x => x.Object.ID == mock.Object.SalesInvoiceID)?.Object);
                mock.Setup(m => m.SalesInvoiceItem).Returns(() => mockingSetup.RawSalesInvoiceItems?.FirstOrDefault(x => x.Object.ID == mock.Object.SalesInvoiceItemID)?.Object);
                mock.Setup(m => m.SalesOrder).Returns(() => mockingSetup.RawSalesOrders?.FirstOrDefault(x => x.Object.ID == mock.Object.SalesOrderID)?.Object);
                mock.Setup(m => m.SalesOrderItem).Returns(() => mockingSetup.RawSalesOrderItems?.FirstOrDefault(x => x.Object.ID == mock.Object.SalesOrderItemID)?.Object);
                mock.Setup(m => m.SalesQuote).Returns(() => mockingSetup.RawSalesQuotes?.FirstOrDefault(x => x.Object.ID == mock.Object.SalesQuoteID)?.Object);
                mock.Setup(m => m.SalesQuoteItem).Returns(() => mockingSetup.RawSalesQuoteItems?.FirstOrDefault(x => x.Object.ID == mock.Object.SalesQuoteItemID)?.Object);
                mock.Setup(m => m.SalesReturn).Returns(() => mockingSetup.RawSalesReturns?.FirstOrDefault(x => x.Object.ID == mock.Object.SalesReturnID)?.Object);
                mock.Setup(m => m.SalesReturnItem).Returns(() => mockingSetup.RawSalesReturnItems?.FirstOrDefault(x => x.Object.ID == mock.Object.SalesReturnItemID)?.Object);
                mock.Setup(m => m.SampleRequest).Returns(() => mockingSetup.RawSampleRequests?.FirstOrDefault(x => x.Object.ID == mock.Object.SampleRequestID)?.Object);
                mock.Setup(m => m.SampleRequestItem).Returns(() => mockingSetup.RawSampleRequestItems?.FirstOrDefault(x => x.Object.ID == mock.Object.SampleRequestItemID)?.Object);
                mock.Setup(m => m.Store).Returns(() => mockingSetup.RawStores?.FirstOrDefault(x => x.Object.ID == mock.Object.StoreID)?.Object);
                mock.Setup(m => m.UpdatedByUser).Returns(() => mockingSetup.RawUsers?.FirstOrDefault(x => x.Object.ID == mock.Object.UpdatedByUserID)?.Object);
                mock.Setup(m => m.User).Returns(() => mockingSetup.RawUsers?.FirstOrDefault(x => x.Object.ID == mock.Object.UserID)?.Object);
                mock.Setup(m => m.Vendor).Returns(() => mockingSetup.RawVendors?.FirstOrDefault(x => x.Object.ID == mock.Object.VendorID)?.Object);
                // Note's Associated Objects
                // Note's Related Objects
                return mock.Object;
            };
            For<INote>().Use(() => mockFuncNote());
            For<Note>().Use(() => mockFuncNote());
            Func<NoteType> mockFuncNoteType = () =>
            {
                var mock = new Mock<NoteType>();
                mock.SetupAllProperties();
                mock.Setup(m => m.ToHashableString()).CallBase();
                // NoteType Properties
                // Dynamic Linking
                // NoteType's Associated Objects
                // NoteType's Related Objects
                return mock.Object;
            };
            For<INoteType>().Use(() => mockFuncNoteType());
            For<NoteType>().Use(() => mockFuncNoteType());
            Func<RecordVersion> mockFuncRecordVersion = () =>
            {
                var mock = new Mock<RecordVersion>();
                mock.SetupAllProperties();
                mock.Setup(m => m.ToHashableString()).CallBase();
                // RecordVersion Properties
                // Dynamic Linking
                // IHaveATypeBase Properties
                mock.Setup(m => m.Type).Returns(() => mockingSetup.RawRecordVersionTypes?.FirstOrDefault(x => x.Object.ID == mock.Object.TypeID)?.Object);
                mock.Setup(m => m.Brand).Returns(() => mockingSetup.RawBrands?.FirstOrDefault(x => x.Object.ID == mock.Object.BrandID)?.Object);
                mock.Setup(m => m.PublishedByUser).Returns(() => mockingSetup.RawUsers?.FirstOrDefault(x => x.Object.ID == mock.Object.PublishedByUserID)?.Object);
                mock.Setup(m => m.Store).Returns(() => mockingSetup.RawStores?.FirstOrDefault(x => x.Object.ID == mock.Object.StoreID)?.Object);
                // RecordVersion's Associated Objects
                // RecordVersion's Related Objects
                return mock.Object;
            };
            For<IRecordVersion>().Use(() => mockFuncRecordVersion());
            For<RecordVersion>().Use(() => mockFuncRecordVersion());
            Func<RecordVersionType> mockFuncRecordVersionType = () =>
            {
                var mock = new Mock<RecordVersionType>();
                mock.SetupAllProperties();
                mock.Setup(m => m.ToHashableString()).CallBase();
                // RecordVersionType Properties
                // Dynamic Linking
                // RecordVersionType's Associated Objects
                // RecordVersionType's Related Objects
                return mock.Object;
            };
            For<IRecordVersionType>().Use(() => mockFuncRecordVersionType());
            For<RecordVersionType>().Use(() => mockFuncRecordVersionType());
            Func<Setting> mockFuncSetting = () =>
            {
                var mock = new Mock<Setting>();
                mock.SetupAllProperties();
                mock.Setup(m => m.ToHashableString()).CallBase();
                // Setting Properties
                // Dynamic Linking
                // IHaveATypeBase Properties
                mock.Setup(m => m.Type).Returns(() => mockingSetup.RawSettingTypes?.FirstOrDefault(x => x.Object.ID == mock.Object.TypeID)?.Object);
                mock.Setup(m => m.Brand).Returns(() => mockingSetup.RawBrands?.FirstOrDefault(x => x.Object.ID == mock.Object.BrandID)?.Object);
                mock.Setup(m => m.SettingGroup).Returns(() => mockingSetup.RawSettingGroups?.FirstOrDefault(x => x.Object.ID == mock.Object.SettingGroupID)?.Object);
                mock.Setup(m => m.Store).Returns(() => mockingSetup.RawStores?.FirstOrDefault(x => x.Object.ID == mock.Object.StoreID)?.Object);
                // Setting's Associated Objects
                // Setting's Related Objects
                return mock.Object;
            };
            For<ISetting>().Use(() => mockFuncSetting());
            For<Setting>().Use(() => mockFuncSetting());
            Func<SettingGroup> mockFuncSettingGroup = () =>
            {
                var mock = new Mock<SettingGroup>();
                mock.SetupAllProperties();
                mock.Setup(m => m.ToHashableString()).CallBase();
                // SettingGroup Properties
                // Dynamic Linking
                // SettingGroup's Associated Objects
                // SettingGroup's Related Objects
                return mock.Object;
            };
            For<ISettingGroup>().Use(() => mockFuncSettingGroup());
            For<SettingGroup>().Use(() => mockFuncSettingGroup());
            Func<SettingType> mockFuncSettingType = () =>
            {
                var mock = new Mock<SettingType>();
                mock.SetupAllProperties();
                mock.Setup(m => m.ToHashableString()).CallBase();
                // SettingType Properties
                // Dynamic Linking
                // SettingType's Associated Objects
                // SettingType's Related Objects
                return mock.Object;
            };
            For<ISettingType>().Use(() => mockFuncSettingType());
            For<SettingType>().Use(() => mockFuncSettingType());
            Func<EventLog> mockFuncEventLog = () =>
            {
                var mock = new Mock<EventLog>();
                mock.SetupAllProperties();
                mock.Setup(m => m.ToHashableString()).CallBase();
                // EventLog Properties
                // Dynamic Linking
                mock.Setup(m => m.Brand).Returns(() => mockingSetup.RawBrands?.FirstOrDefault(x => x.Object.ID == mock.Object.BrandID)?.Object);
                mock.Setup(m => m.Store).Returns(() => mockingSetup.RawStores?.FirstOrDefault(x => x.Object.ID == mock.Object.StoreID)?.Object);
                // EventLog's Associated Objects
                // EventLog's Related Objects
                return mock.Object;
            };
            For<IEventLog>().Use(() => mockFuncEventLog());
            For<EventLog>().Use(() => mockFuncEventLog());
        }
    }
}
