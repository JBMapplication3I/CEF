<#@ template hostSpecific="true" language="C#"
#><#@ output extension=".cstxt"
#><#@ assembly name="System"
#><#@ assembly name="System.Core"
#><#@ assembly name="System.ComponentModel.DataAnnotations"
#><#@ assembly name="$(UserProfile)\.nuget\packages\entityframework\6.4.4\lib\net45\EntityFramework.dll"
#><#@ assembly name="$(SolutionDir)01.DataAccessLayer\01.Clarity.Ecommerce.DataModel\bin\Debug\net472\Clarity.Ecommerce.DataModel.dll"
#><#@ assembly name="$(SolutionDir)11.T4\11.T4.CodeGenerator\bin\Debug\net472\CodeGenerator.dll"
#><#@ import namespace="System.Collections.Generic"
#><#@ import namespace="System.ComponentModel.DataAnnotations"
#><#@ import namespace="System.ComponentModel.DataAnnotations.Schema"
#><#@ import namespace="System.Data.Entity"
#><#@ import namespace="System.Linq"
#><#@ import namespace="System.Reflection"
#><#@ import namespace="System.Runtime.InteropServices"
#><#@ import namespace="System.Text"
#><#@ import namespace="CodeGenerator"
#><#@ import namespace="Clarity.Ecommerce.Interfaces.DataModel"
#><#@ import namespace="Clarity.Ecommerce.DataModel"
#><#@ include file="$(SolutionDir)11.T4\11.T4.CodeGenerator\MultiOutput.old.ttinclude"
#><#
IEnumerable<IGrouping<string, Type>> tableClasses = AppDomain.CurrentDomain.GetAssemblies()
    .Where(x => x.FullName.StartsWith("Clarity.Ecommerce.DataModel"))
    .SelectMany(x => x.GetTypes().Where(t => t.CustomAttributes.Any(at => at.AttributeType == typeof(SqlSchemaAttribute))))
    .OrderBy(x => ((SqlSchemaAttribute)Attribute.GetCustomAttribute(x, typeof(SqlSchemaAttribute))).Both)
    .GroupBy(x => ((SqlSchemaAttribute)Attribute.GetCustomAttribute(x, typeof(SqlSchemaAttribute))).Schema);
List<string> processedNames = new List<string>() { "Report" };
List<string> skipProperties = new List<string> {
    "ID", "CustomKey", "Active", "CreatedDate", "UpdatedDate", "Hash", "SerializableAttributes", "JsonAttributes",
    "OriginalBytes", "ThumbnailBytes", "Role",
};
foreach (IGrouping<string, Type> @group in tableClasses)
{
    foreach (Type theType in @group)
    {
        string modelName = HelpFunctions.SwapToModelType(theType.Name);
        if (processedNames.Contains(theType.Name))
        { #>
// <#= theType.Name #>-><#= modelName #> skipped (already processed)
<#          SaveOutput(@group.Key + "\\" + theType.Name, "generated.cstxt", true);
            continue;
        }
        processedNames.Add(theType.Name);
        TypeDeterminer td = new TypeDeterminer(theType);
        if (td.IsExcludedFromT4)
        { #>
// <#= theType.Name #>-><#= modelName #> skipped (IsExcludedFromT4)
<#          SaveOutput(@group.Key + "\\" + theType.Name, "generated.cstxt", true);
            continue;
        }
        string pluralized = HelpFunctions.PluralizeName(theType.Name);
        string splitCamelCased = HelpFunctions.SplitCamelCase(theType.Name);
#>// <autogenerated>
// <copyright file="<#= @group.Key #>.ISearchModels.cs" company="clarity-ventures.com">
// Copyright (c) 2021-<#= DateTime.Today.Year #> clarity-ventures.com. All rights reserved.
// </copyright>
// <summary>Implements the FilterBy Query Extensions generated to provide searching queries.</summary>
// <remarks>This file was auto-generated by FilterBys.tt, changes to this
// file will be overwritten automatically when the T4 template is run again.</remarks>
// </autogenerated>
// ReSharper disable PartialTypeWithSinglePart, RedundantUsingDirective, RegionWithSingleElement
#pragma warning disable 8669 // nullable reference types disabled
#nullable enable
namespace Clarity.Ecommerce.Interfaces.Models
{
    using System;
    using System.Linq;
    using DataModel;
    using Ecommerce.DataModel;
    using Utilities;

    /// <content>The <#= splitCamelCased #> SQL search extensions.</content>
<#      if (td.IsDeprecated) { #>
    /// <obsolete><#= td.DeprecatedMessage #></obsolete>
    [Obsolete("<#= td.DeprecatedMessage #>", false)]
<#      } #>
    public static partial class <#= theType.Name #>SQLSearchExtensions
    {
        /// <summary>An <see cref="IQueryable{<#= theType.Name #>}" /> extension method that filters  by each of the properties of
        /// the search model which have been set.</summary>
        /// <remarks>Pass a parameter value of null to not filter by this in a fluid call chain.</remarks>
        /// <param name="query">The query to act on.</param>
        /// <param name="model">The search model to filter by.</param>
        /// <returns>The <see cref="IQueryable{<#= theType.Name #>}" /> with an additional Where applied if the parameter has a value.</returns>
        public static IQueryable<<#= theType.Name #>> Filter<#= pluralized #>BySearchModel(
                this IQueryable<<#= theType.Name #>> query,
                I<#= modelName #>SearchModel model)
        {
            if (model == null)
            {
                return query;
            }
            var query2 = Contract.RequiresNotNull(query)
<#      if (td.IsISalesCollectionBase) { #>
                .FilterSalesCollectionsBySearchModel<<#= theType.Name #>,
                    <#= theType.Name #>Status,
                    <#= theType.Name #>Type,
                    <#= theType.Name #>Item,
                    Applied<#= theType.Name #>Discount,
                    <#= theType.Name #>State,
                    <#= theType.Name #>File,
                    <#= theType.Name #>Contact,
                    Applied<#= theType.Name #>ItemDiscount,
                    <#= theType.Name #>ItemTarget,
                    <#= theType.Name #>Event,
                    <#= theType.Name #>EventType>(model)
<#      } else if (td.IsISalesItemBase) { #>
                .FilterBySalesItemBaseSearchModel<<#= theType.Name #>, Applied<#= theType.Name #>Discount, <#= theType.Name #>Target>(model)
<#      } else if (td.IsISalesEventBase) { #>
                .FilterBySalesEventBaseSearchModel<<#= theType.Name #>, <#= theType.Name.Replace("Event", string.Empty) #>, <#= theType.Name #>Type>(model)
<#      } else { #>
                .FilterBy<#= td.IsIStatusableBase ? "Statusable" : "" #><#= td.IsIStateableBase ? "Stateable" : "" #><#= td.IsITypableBase ? "Typable" : ""
            #><#= !td.IsIStatusableBase && !td.IsIStateableBase && !td.IsITypableBase && td.IsINameableBase ? "Nameable" : "" #>BaseSearchModel(model)
<#      } #>
<#      if (td.IsIAmARelationshipTable) { #>
                .FilterByIAmARelationshipTableBaseSearchModel<<#= theType.Name #>, <#= td.RelationshipPrimaryType.Name #>, <#= td.RelationshipSecondaryType.Name #>>(model)
<#      } #>
<#      if (td.IsIAmFilterableByAccountT && td.IAmFilterableByAccountTType.Name.EndsWith(theType.Name)) { #>
                .FilterIAmFilterableByMasterAccountsBySearchModel<<#= theType.Name #>, <#= td.IAmFilterableByAccountTType.Name #>>(model)
<#      } #>
<#      if (td.IsIAmFilterableByAccountT && td.IAmFilterableByAccountTType.Name.StartsWith(theType.Name)) { #>
                .FilterIAmFilterableBySlaveAccountsBySearchModel<<#= theType.Name #>, <#= td.IAmFilterableByAccountTType.Name #>>(model)
<#      } #>
<#      if (td.IsIAmFilterableByAccount && !(td.IsIAmARelationshipTable && (td.RelationshipPrimaryType.Name == "Account" || td.RelationshipSecondaryType.Name == "Account"))) { #>
                .FilterByIAmFilterableByAccountSearchModel(model)
<#      } #>
<#      if (td.IsIAmFilterableByNullableAccount) { #>
                .FilterByIAmFilterableByNullableAccountSearchModel(model)
<#      } #>
<#      if (td.IsIAmFilterableByBrandT && td.IAmFilterableByBrandTType.Name.EndsWith(theType.Name)) { #>
                .FilterIAmFilterableByMasterBrandsBySearchModel<<#= theType.Name #>, <#= td.IAmFilterableByBrandTType.Name #>>(model)
<#      } #>
<#      if (td.IsIAmFilterableByBrandT && td.IAmFilterableByBrandTType.Name.StartsWith(theType.Name)) { #>
                .FilterIAmFilterableBySlaveBrandsBySearchModel<<#= theType.Name #>, <#= td.IAmFilterableByBrandTType.Name #>>(model)
<#      } #>
<#      if (td.IsIAmFilterableByBrand && !(td.IsIAmARelationshipTable && (td.RelationshipPrimaryType.Name == "Brand" || td.RelationshipSecondaryType.Name == "Brand"))) { #>
                .FilterByIAmFilterableByBrandSearchModel(model)
<#      } #>
<#      if (td.IsIAmFilterableByNullableBrand) { #>
                .FilterByIAmFilterableByNullableBrandSearchModel(model)
<#      } #>
<#      if (td.IsIAmFilterableByCategoryT && td.IAmFilterableByCategoryTType.Name.EndsWith(theType.Name)) { #>
                .FilterIAmFilterableByMasterCategoriesBySearchModel<<#= theType.Name #>, <#= td.IAmFilterableByCategoryTType.Name #>>(model)
<#      } #>
<#      if (td.IsIAmFilterableByCategoryT && td.IAmFilterableByCategoryTType.Name.StartsWith(theType.Name)) { #>
                .FilterIAmFilterableBySlaveCategoriesBySearchModel<<#= theType.Name #>, <#= td.IAmFilterableByCategoryTType.Name #>>(model)
<#      } #>
<#      if (td.IsIAmFilterableByCategory && !(td.IsIAmARelationshipTable && (td.RelationshipPrimaryType.Name == "Category" || td.RelationshipSecondaryType.Name == "Category"))) { #>
                .FilterByIAmFilterableByCategorySearchModel(model)
<#      } #>
<#      if (td.IsIAmFilterableByNullableCategory) { #>
                .FilterByIAmFilterableByNullableCategorySearchModel(model)
<#      } #>
<#      if (td.IsIAmFilterableByFranchiseT && td.IAmFilterableByFranchiseTType.Name.EndsWith(theType.Name)) { #>
                .FilterIAmFilterableByMasterFranchisesBySearchModel<<#= theType.Name #>, <#= td.IAmFilterableByFranchiseTType.Name #>>(model)
<#      } #>
<#      if (td.IsIAmFilterableByFranchiseT && td.IAmFilterableByFranchiseTType.Name.StartsWith(theType.Name)) { #>
                .FilterIAmFilterableBySlaveFranchisesBySearchModel<<#= theType.Name #>, <#= td.IAmFilterableByFranchiseTType.Name #>>(model)
<#      } #>
<#      if (td.IsIAmFilterableByFranchise && !(td.IsIAmARelationshipTable && (td.RelationshipPrimaryType.Name == "Franchise" || td.RelationshipSecondaryType.Name == "Franchise"))) { #>
                .FilterByIAmFilterableByFranchiseSearchModel(model)
<#      } #>
<#      if (td.IsIAmFilterableByNullableFranchise) { #>
                .FilterByIAmFilterableByNullableFranchiseSearchModel(model)
<#      } #>
<#      if (td.IsIAmFilterableByManufacturerT && td.IAmFilterableByManufacturerTType.Name.EndsWith(theType.Name)) { #>
                .FilterIAmFilterableByMasterManufacturersBySearchModel<<#= theType.Name #>, <#= td.IAmFilterableByManufacturerTType.Name #>>(model)
<#      } #>
<#      if (td.IsIAmFilterableByManufacturerT && td.IAmFilterableByManufacturerTType.Name.StartsWith(theType.Name)) { #>
                .FilterIAmFilterableBySlaveManufacturersBySearchModel<<#= theType.Name #>, <#= td.IAmFilterableByManufacturerTType.Name #>>(model)
<#      } #>
<#      if (td.IsIAmFilterableByManufacturer && !(td.IsIAmARelationshipTable && (td.RelationshipPrimaryType.Name == "Manufacturer" || td.RelationshipSecondaryType.Name == "Manufacturer"))) { #>
                .FilterByIAmFilterableByManufacturerSearchModel(model)
<#      } #>
<#      if (td.IsIAmFilterableByNullableManufacturer) { #>
                .FilterByIAmFilterableByNullableManufacturerSearchModel(model)
<#      } #>
<#      if (td.IsIAmFilterableByProductT && td.IAmFilterableByProductTType.Name.EndsWith(theType.Name)) { #>
                .FilterIAmFilterableByMasterProductsBySearchModel<<#= theType.Name #>, <#= td.IAmFilterableByProductTType.Name #>>(model)
<#      } #>
<#      if (td.IsIAmFilterableByProductT && td.IAmFilterableByProductTType.Name.StartsWith(theType.Name)) { #>
                .FilterIAmFilterableBySlaveProductsBySearchModel<<#= theType.Name #>, <#= td.IAmFilterableByProductTType.Name #>>(model)
<#      } #>
<#      if (td.IsIAmFilterableByProduct && !(td.IsIAmARelationshipTable && (td.RelationshipPrimaryType.Name == "Product" || td.RelationshipSecondaryType.Name == "Product"))) { #>
                .FilterByIAmFilterableByProductSearchModel(model)
<#      } #>
<#      if (td.IsIAmFilterableByNullableProduct) { #>
                .FilterByIAmFilterableByNullableProductSearchModel(model)
<#      } #>
<#      if (td.IsIAmFilterableByStoreT && td.IAmFilterableByStoreTType.Name.EndsWith(theType.Name)) { #>
                .FilterIAmFilterableByMasterStoresBySearchModel<<#= theType.Name #>, <#= td.IAmFilterableByStoreTType.Name #>>(model)
<#      } #>
<#      if (td.IsIAmFilterableByStoreT && td.IAmFilterableByStoreTType.Name.StartsWith(theType.Name)) { #>
                .FilterIAmFilterableBySlaveStoresBySearchModel<<#= theType.Name #>, <#= td.IAmFilterableByStoreTType.Name #>>(model)
<#      } #>
<#      if (td.IsIAmFilterableByStore && !(td.IsIAmARelationshipTable && (td.RelationshipPrimaryType.Name == "Store" || td.RelationshipSecondaryType.Name == "Store"))) { #>
                .FilterByIAmFilterableByStoreSearchModel(model)
<#      } #>
<#      if (td.IsIAmFilterableByNullableStore) { #>
                .FilterByIAmFilterableByNullableStoreSearchModel(model)
<#      } #>
<#      if (td.IsIAmFilterableByUserT && td.IAmFilterableByUserTType.Name.EndsWith(theType.Name)) { #>
                .FilterIAmFilterableByMasterUsersBySearchModel<<#= theType.Name #>, <#= td.IAmFilterableByUserTType.Name #>>(model)
<#      } #>
<#      if (td.IsIAmFilterableByUserT && td.IAmFilterableByUserTType.Name.StartsWith(theType.Name)) { #>
                .FilterIAmFilterableBySlaveUsersBySearchModel<<#= theType.Name #>, <#= td.IAmFilterableByUserTType.Name #>>(model)
<#      } #>
<#      if (td.IsIAmFilterableByUser && !(td.IsIAmARelationshipTable && (td.RelationshipPrimaryType.Name == "User" || td.RelationshipSecondaryType.Name == "User"))) { #>
                .FilterByIAmFilterableByUserSearchModel(model)
<#      } #>
<#      if (td.IsIAmFilterableByNullableUser) { #>
                .FilterByIAmFilterableByNullableUserSearchModel(model)
<#      } #>
<#      if (td.IsIAmFilterableByVendorT && td.IAmFilterableByVendorTType.Name.EndsWith(theType.Name)) { #>
                .FilterIAmFilterableByMasterVendorsBySearchModel<<#= theType.Name #>, <#= td.IAmFilterableByVendorTType.Name #>>(model)
<#      } #>
<#      if (td.IsIAmFilterableByVendorT && td.IAmFilterableByVendorTType.Name.StartsWith(theType.Name)) { #>
                .FilterIAmFilterableBySlaveVendorsBySearchModel<<#= theType.Name #>, <#= td.IAmFilterableByVendorTType.Name #>>(model)
<#      } #>
<#      if (td.IsIAmFilterableByVendor && !(td.IsIAmARelationshipTable && (td.RelationshipPrimaryType.Name == "Vendor" || td.RelationshipSecondaryType.Name == "Vendor"))) { #>
                .FilterByIAmFilterableByVendorSearchModel(model)
<#      } #>
<#      if (td.IsIAmFilterableByNullableVendor) { #>
                .FilterByIAmFilterableByNullableVendorSearchModel(model)
<#      } #>
<#      if (td.IsIHaveATypeBase && !td.IsISalesEventBase) { #>
                .FilterByHaveATypeSearchModel<<#= theType.Name #>, <#= theType.Name
            .Replace("GeneralAttribute", "Attribute").Replace("EmailQueue", "Email").Replace("SalesInvoiceItem", "SalesItem")
            .Replace("SalesOrderItem", "SalesItem").Replace("SalesQuoteItem", "SalesItem").Replace("SalesReturnItem", "SalesItem")
            .Replace("PurchaseOrderItem", "SalesItem").Replace("SampleRequestItem", "SalesItem").Replace("CartItem", "SalesItem")
            #>Type>(model)
<#      } #>
<#      if (td.IsIHaveAStatusBase) { #>
                .FilterByHaveAStatusSearchModel<<#= theType.Name #>, <#= theType.Name.Replace("EmailQueue", "Email") #>Status>(model)
<#      } #>
<#      if (td.IsIHaveAStateBase) { #>
                .FilterByHaveAStateSearchModel<<#= theType.Name #>, <#= theType.Name #>State>(model)
<#      } #>
<#      if (td.IsIHaveAContactBase && !(td.IsIAmARelationshipTable && (td.RelationshipPrimaryType.Name == "Contact" || td.RelationshipSecondaryType.Name == "Contact"))) { #>
                .FilterIHaveAContactBaseBySearchModel(model)
<#      } #>
<#      if (td.IsIHaveANullableContactBase) { #>
                .FilterIHaveANullableContactBaseBySearchModel(model)
<#      } #>
<#      if (td.IsIHaveAParentBase) { #>
                .FilterIHaveAParentBasesBySearchModel(model)
<#      } #>
<#      if (td.IsIHaveRequiresRolesBase && false) { /* Not implemented yet */ #>
                .FilterIHaveRequiresRolesBaseBySearchModel(model)
<#      } #>
<#      if (td.IsIHaveSeoBase) { #>
                .FilterIHaveSeoBaseBySearchModel(model)
<#      } #>
<#      if (td.IsIHaveNotesBase && false) { /* Not implemented yet */ #>
                .FilterIHaveNotesBaseBySearchModel(model)
<#      } #>
<#
        List<string> thisSkipProperties = new List<string>(skipProperties);
        if (td.IsINameableBase)
        {
            thisSkipProperties.AddRange(new[] { "Name", "Description" });
        }
        if (td.IsIDisplayableBase)
        {
            thisSkipProperties.AddRange(new[] { "DisplayName", "SortOrder", "TranslationKey" });
        }
        if (td.IsIHaveATypeBase)
        {
            thisSkipProperties.AddRange(new[] { "TypeID", "Type" });
        }
        if (td.IsIHaveAStatusBase)
        {
            thisSkipProperties.AddRange(new[] { "StatusID", "Status" });
        }
        if (td.IsIHaveAStateBase)
        {
            thisSkipProperties.AddRange(new[] { "StateID", "State" });
        }
        if (td.IsIAmARelationshipTable)
        {
            thisSkipProperties.AddRange(new[] { "MasterID", "Master", "SlaveID", "Slave" });
        }
        if (td.IsIHaveSeoBase)
        {
            thisSkipProperties.AddRange(new[] { "SeoDescription", "SeoKeywords", "SeoMetaData", "SeoPageTitle", "SeoUrl" });
        }
        if (td.IsIAmAStoredFileRelationshipTable)
        {
            thisSkipProperties.AddRange(new[] { "SortOrder" });
        }
        if (td.IsISalesEventBase)
        {
            thisSkipProperties.AddRange(new[]
            {
                "MasterID", "Master",
                "OldStateID", "NewStateID",
                "OldStatusID", "NewStatusID",
                "OldTypeID", "NewTypeID",
                "OldHash", "NewHash",
                "OldRecordSerialized", "NewRecordSerialized",
                "OldBalanceDue", "NewBalanceDue",
            });
        }
        if (td.IsISalesItemBase)
        {
            thisSkipProperties.AddRange(new[]
            {
                "Sku", "ForceUniqueLineItemKey", "UnitOfMeasure",
                "Quantity", "QuantityBackOrdered", "QuantityPreSold",
                "UnitCorePrice", "UnitSoldPrice", "UnitCorePriceInSellingCurrency", "UnitSoldPriceInSellingCurrency",
                "MasterID", "OriginalCurrencyID", "SellingCurrencyID", "ProductID", "UserID",
            });
        }
        if (td.IsIAmFilterableByAccountT || td.IsIAmFilterableByAccount || td.IsIAmFilterableByNullableAccount)
        {
            thisSkipProperties.AddRange(new[] { "AccountID" });
        }
        if (td.IsIAmFilterableByBrandT || td.IsIAmFilterableByBrand || td.IsIAmFilterableByNullableBrand)
        {
            thisSkipProperties.AddRange(new[] { "BrandID" });
        }
        if (td.IsIAmFilterableByCategoryT || td.IsIAmFilterableByCategory || td.IsIAmFilterableByNullableCategory)
        {
            thisSkipProperties.AddRange(new[] { "CategoryID" });
        }
        if (td.IsIAmFilterableByFranchiseT || td.IsIAmFilterableByFranchise || td.IsIAmFilterableByNullableFranchise)
        {
            thisSkipProperties.AddRange(new[] { "FranchiseID" });
        }
        if (td.IsIAmFilterableByManufacturerT || td.IsIAmFilterableByManufacturer || td.IsIAmFilterableByNullableManufacturer)
        {
            thisSkipProperties.AddRange(new[] { "ManufacturerID" });
        }
        if (td.IsIAmFilterableByProductT || td.IsIAmFilterableByProduct || td.IsIAmFilterableByNullableProduct)
        {
            thisSkipProperties.AddRange(new[] { "ProductID" });
        }
        if (td.IsIAmFilterableByStoreT || td.IsIAmFilterableByStore || td.IsIAmFilterableByNullableStore)
        {
            thisSkipProperties.AddRange(new[] { "StoreID" });
        }
        if (td.IsIAmFilterableByUserT || td.IsIAmFilterableByUser || td.IsIAmFilterableByNullableUser)
        {
            thisSkipProperties.AddRange(new[] { "UserID" });
        }
        if (td.IsIAmFilterableByVendorT || td.IsIAmFilterableByVendor|| td.IsIAmFilterableByNullableVendor)
        {
            thisSkipProperties.AddRange(new[] { "VendorID" });
        }
        List<PropertyInfo> properties = theType.GetProperties()
            .Where(x => !thisSkipProperties.Contains(x.Name)
                && x.PropertyType.Name != "ICollection`1"
                && x.PropertyType.Name != "Byte[]"
                && x.PropertyType.GetInterface("IBase") == null
                && x.GetCustomAttribute<NotMappedAttribute>() == null)
            .OrderBy(x => x.PropertyType.Name)
            .ThenBy(x => x.Name)
            .ToList();
        var counter = 0;
#>
<#      foreach (PropertyInfo p in properties) {
            if (++counter > 30) {
                counter = 0; #>
                ; // Forced clip to prevent CS8078
            query2 = query2
<#          }
            if (p.PropertyType == typeof(DateTime) || p.PropertyType == typeof(DateTime?)) { #>
                .Filter<#= pluralized #>ByMin<#= p.Name #>(model.Min<#= p.Name #>)
                .Filter<#= pluralized #>ByMax<#= p.Name #>(model.Max<#= p.Name #>)
                .Filter<#= pluralized #>ByMatch<#= p.Name #>(model.Match<#= p.Name #><#=
                    p.PropertyType == typeof(DateTime?) ? ", model.Match" + p.Name + "IncludeNull" : string.Empty #>)
<#          } else if (p.PropertyType == typeof(decimal) || p.PropertyType == typeof(decimal?)) { #>
                .Filter<#= pluralized #>ByMin<#= p.Name #>(model.Min<#= p.Name #>)
                .Filter<#= pluralized #>ByMax<#= p.Name #>(model.Max<#= p.Name #>)
                .Filter<#= pluralized #>ByMatch<#= p.Name #>(model.Match<#= p.Name #><#=
                    p.PropertyType == typeof(decimal?) ? ", model.Match" + p.Name + "IncludeNull" : string.Empty #>)
<#          } else if (p.PropertyType == typeof(long) || p.PropertyType == typeof(long?)) { #>
                .Filter<#= pluralized #>ByMin<#= p.Name #>(model.Min<#= p.Name #>)
                .Filter<#= pluralized #>ByMax<#= p.Name #>(model.Max<#= p.Name #>)
                .Filter<#= pluralized #>ByMatch<#= p.Name #>(model.Match<#= p.Name #><#=
                    p.PropertyType == typeof(long?) ? ", model.Match" + p.Name + "IncludeNull" : string.Empty #>)
<#          } else if (p.PropertyType == typeof(bool) || p.PropertyType == typeof(bool?)) { #>
                .Filter<#= pluralized #>By<#= p.Name #>(model.<#= p.Name #><#=
                    p.PropertyType == typeof(bool?) ? ", model." + p.Name + "IncludeNull" : string.Empty #>)
<#          } else if (p.PropertyType == typeof(Guid) || p.PropertyType == typeof(Guid?)) { #>
                .Filter<#= pluralized #>By<#= p.Name #>(model.<#= p.Name #><#=
                    p.PropertyType == typeof(Guid?) ? ", model." + p.Name + "IncludeNull" : string.Empty #>)
<#          } else if ((p.PropertyType == typeof(int) || p.PropertyType == typeof(int?)) && p.Name.EndsWith("ID")) { #>
                .Filter<#= pluralized #>By<#= p.Name #>(model.<#= p.Name #><#=
                    p.PropertyType == typeof(int?) ? ", model." + p.Name + "IncludeNull" : string.Empty #>)
<#          } else if (p.PropertyType == typeof(string)/* || p.PropertyType == typeof(string?)*/) { #>
                .Filter<#= pluralized #>By<#= p.Name #>(model.<#= p.Name #>, model.<#= p.Name #>Strict<#=
                    /*p.PropertyType == typeof(string?)*/true ? ", model." + p.Name + "IncludeNull" : string.Empty #>)
<#          } else if (p.PropertyType == typeof(int) || p.PropertyType == typeof(int?)) { #>
                .Filter<#= pluralized #>ByMin<#= p.Name #>(model.Min<#= p.Name #>)
                .Filter<#= pluralized #>ByMax<#= p.Name #>(model.Max<#= p.Name #>)
                .Filter<#= pluralized #>ByMatch<#= p.Name #>(model.Match<#= p.Name #><#=
                    p.PropertyType == typeof(int?) ? ", model.Match" + p.Name + "IncludeNull" : string.Empty #>)
<#          } else { #>
                .Filter<#= pluralized #>By<#= p.Name #>(model.<#= p.Name #>)
<#          } #>
<#      } #>
                ;
            return query2;
        }
<#      foreach (PropertyInfo p in properties) { #>

        #region <#= p.Name #>
<#          if (p.PropertyType == typeof(DateTime) || p.PropertyType == typeof(DateTime?)) { #>
        /// <summary>An <see cref="IQueryable{TEntity}" /> extension method that filters records by the parameter (a minimum Date/Time).</summary>
        /// <remarks>Pass a parameter value of null to not filter by this in a fluid call chain.</remarks>
        /// <typeparam name="TEntity">Type of the entity.</typeparam>
        /// <param name="query">    The query to act on.</param>
        /// <param name="parameter">The parameter to filter by.</param>
        /// <returns>The <see cref="IQueryable{TEntity}" /> with an additional Where applied if the parameter has a value.</returns>
        public static IQueryable<TEntity> Filter<#= pluralized #>ByMin<#= p.Name #><TEntity>(
                this IQueryable<TEntity> query,
                DateTime? parameter)
            where TEntity : class, I<#= theType.Name #>
        {
            if (!Contract.CheckValidDate(parameter))
            {
                return query;
            }
            return Contract.RequiresNotNull(query)
                .Where(x => x.<#= p.Name #> >= parameter!.Value);
        }

        /// <summary>An <see cref="IQueryable{TEntity}" /> extension method that filters records by the parameter (a maximum Date/Time).</summary>
        /// <remarks>Pass a parameter value of null to not filter by this in a fluid call chain.</remarks>
        /// <typeparam name="TEntity">Type of the entity.</typeparam>
        /// <param name="query">    The query to act on.</param>
        /// <param name="parameter">The parameter to filter by.</param>
        /// <returns>The <see cref="IQueryable{TEntity}" /> with an additional Where applied if the parameter has a value.</returns>
        public static IQueryable<TEntity> Filter<#= pluralized #>ByMax<#= p.Name #><TEntity>(
                this IQueryable<TEntity> query,
                DateTime? parameter)
            where TEntity : class, I<#= theType.Name #>
        {
            if (!Contract.CheckValidDate(parameter))
            {
                return query;
            }
            return Contract.RequiresNotNull(query)
                .Where(x => x.<#= p.Name #> <= parameter!.Value);
        }

        /// <summary>An <see cref="IQueryable{TEntity}" /> extension method that filters records by the parameter (a Date/Time to match exactly).</summary>
        /// <remarks>Pass a parameter value of null to not filter by this in a fluid call chain.</remarks>
        /// <typeparam name="TEntity">Type of the entity.</typeparam>
        /// <param name="query">      The query to act on.</param>
        /// <param name="parameter">  The parameter to filter by.</param>
<#      if (p.PropertyType == typeof(DateTime?)) { #>
        /// <param name="includeNull">If set, match the parameter even if it's null.</param>
<#      } #>
        /// <returns>The <see cref="IQueryable{TEntity}" /> with an additional Where applied if the parameter has a value.</returns>
        public static IQueryable<TEntity> Filter<#= pluralized #>ByMatch<#= p.Name #><TEntity>(
                this IQueryable<TEntity> query,
                DateTime? parameter<#=
                    p.PropertyType == typeof(DateTime?) ? ",\r\n                bool? includeNull" : string.Empty #>)
            where TEntity : class, I<#= theType.Name #>
        {
            if (<#= p.PropertyType == typeof(DateTime?) ? "includeNull != true && " : string.Empty #>!Contract.CheckValidDate(parameter))
            {
                return query;
            }
            return Contract.RequiresNotNull(query)
                .Where(x => x.<#= p.Name #> == parameter);
        }
<#          } else if (p.PropertyType == typeof(decimal) || p.PropertyType == typeof(decimal?)) { #>
        /// <summary>An <see cref="IQueryable{TEntity}" /> extension method that filters records by the parameter (a minimum decimal value).</summary>
        /// <remarks>Pass a parameter value of null to not filter by this in a fluid call chain.</remarks>
        /// <typeparam name="TEntity">Type of the entity.</typeparam>
        /// <param name="query">    The query to act on.</param>
        /// <param name="parameter">The parameter to filter by.</param>
        /// <returns>The <see cref="IQueryable{TEntity}" /> with an additional Where applied if the parameter has a value.</returns>
        public static IQueryable<TEntity> Filter<#= pluralized #>ByMin<#= p.Name #><TEntity>(
                this IQueryable<TEntity> query,
                decimal? parameter)
            where TEntity : class, I<#= theType.Name #>
        {
            if (!parameter.HasValue)
            {
                return query;
            }
            var search = parameter.Value;
            return Contract.RequiresNotNull(query)
                .Where(x => x.<#= p.Name #> >= search);
        }

        /// <summary>An <see cref="IQueryable{TEntity}" /> extension method that filters records by the parameter (a maximum decimal value).</summary>
        /// <remarks>Pass a parameter value of null to not filter by this in a fluid call chain.</remarks>
        /// <typeparam name="TEntity">Type of the entity.</typeparam>
        /// <param name="query">    The query to act on.</param>
        /// <param name="parameter">The parameter to filter by.</param>
        /// <returns>The <see cref="IQueryable{TEntity}" /> with an additional Where applied if the parameter has a value.</returns>
        public static IQueryable<TEntity> Filter<#= pluralized #>ByMax<#= p.Name #><TEntity>(
                this IQueryable<TEntity> query,
                decimal? parameter)
            where TEntity : class, I<#= theType.Name #>
        {
            if (!parameter.HasValue)
            {
                return query;
            }
            return Contract.RequiresNotNull(query)
                .Where(x => x.<#= p.Name #> <= parameter.Value);
        }

        /// <summary>An <see cref="IQueryable{TEntity}" /> extension method that filters records by the parameter (a decimal value to match exactly).</summary>
        /// <remarks>Pass a parameter value of null to not filter by this in a fluid call chain.</remarks>
        /// <typeparam name="TEntity">Type of the entity.</typeparam>
        /// <param name="query">      The query to act on.</param>
        /// <param name="parameter">  The parameter to filter by.</param>
<#      if (p.PropertyType == typeof(decimal?)) { #>
        /// <param name="includeNull">If set, match the parameter even if it's null.</param>
<#      } #>
        /// <returns>The <see cref="IQueryable{TEntity}" /> with an additional Where applied if the parameter has a value.</returns>
        public static IQueryable<TEntity> Filter<#= pluralized #>ByMatch<#= p.Name #><TEntity>(
                this IQueryable<TEntity> query,
                decimal? parameter<#=
                    p.PropertyType == typeof(decimal?) ? ",\r\n                bool? includeNull" : string.Empty #>)
            where TEntity : class, I<#= theType.Name #>
        {
            if (<#= p.PropertyType == typeof(decimal?) ? "includeNull != true && " : string.Empty #>!parameter.HasValue)
            {
                return query;
            }
            return Contract.RequiresNotNull(query)
                .Where(x => x.<#= p.Name #> == parameter);
        }
<#          } else if (p.PropertyType == typeof(long) || p.PropertyType == typeof(long?)) { #>
        /// <summary>An <see cref="IQueryable{TEntity}" /> extension method that filters records by the parameter (a minimum long value).</summary>
        /// <remarks>Pass a parameter value of null to not filter by this in a fluid call chain.</remarks>
        /// <typeparam name="TEntity">Type of the entity.</typeparam>
        /// <param name="query">    The query to act on.</param>
        /// <param name="parameter">The parameter to filter by.</param>
        /// <returns>The <see cref="IQueryable{TEntity}" /> with an additional Where applied if the parameter has a value.</returns>
        public static IQueryable<TEntity> Filter<#= pluralized #>ByMin<#= p.Name #><TEntity>(
                this IQueryable<TEntity> query,
                long? parameter)
            where TEntity : class, I<#= theType.Name #>
        {
            if (!parameter.HasValue)
            {
                return query;
            }
            var search = parameter.Value;
            return Contract.RequiresNotNull(query)
                .Where(x => x.<#= p.Name #> >= search);
        }

        /// <summary>An <see cref="IQueryable{TEntity}" /> extension method that filters records by the parameter (a maximum long value).</summary>
        /// <remarks>Pass a parameter value of null to not filter by this in a fluid call chain.</remarks>
        /// <typeparam name="TEntity">Type of the entity.</typeparam>
        /// <param name="query">    The query to act on.</param>
        /// <param name="parameter">The parameter to filter by.</param>
        /// <returns>The <see cref="IQueryable{TEntity}" /> with an additional Where applied if the parameter has a value.</returns>
        public static IQueryable<TEntity> Filter<#= pluralized #>ByMax<#= p.Name #><TEntity>(
                this IQueryable<TEntity> query,
                long? parameter)
            where TEntity : class, I<#= theType.Name #>
        {
            if (!parameter.HasValue)
            {
                return query;
            }
            return Contract.RequiresNotNull(query)
                .Where(x => x.<#= p.Name #> <= parameter.Value);
        }

        /// <summary>An <see cref="IQueryable{TEntity}" /> extension method that filters records by the parameter (a long value to match exactly).</summary>
        /// <remarks>Pass a parameter value of null to not filter by this in a fluid call chain.</remarks>
        /// <typeparam name="TEntity">Type of the entity.</typeparam>
        /// <param name="query">      The query to act on.</param>
        /// <param name="parameter">  The parameter to filter by.</param>
<#      if (p.PropertyType == typeof(long?)) { #>
        /// <param name="includeNull">If set, match the parameter even if it's null.</param>
<#      } #>
        /// <returns>The <see cref="IQueryable{TEntity}" /> with an additional Where applied if the parameter has a value.</returns>
        public static IQueryable<TEntity> Filter<#= pluralized #>ByMatch<#= p.Name #><TEntity>(
                this IQueryable<TEntity> query,
                long? parameter<#=
                    p.PropertyType == typeof(long?) ? ",\r\n                bool? includeNull" : string.Empty #>)
            where TEntity : class, I<#= theType.Name #>
        {
            if (<#= p.PropertyType == typeof(long?) ? "includeNull != true && " : string.Empty #>!parameter.HasValue)
            {
                return query;
            }
            return Contract.RequiresNotNull(query)
                .Where(x => x.<#= p.Name #> == parameter);
        }
<#          } else if (p.PropertyType == typeof(bool) || p.PropertyType == typeof(bool?)) { #>
        /// <summary>An <see cref="IQueryable{TEntity}" /> extension method that filters records by the parameter (a boolean value).</summary>
        /// <remarks>Pass a parameter value of null to not filter by this in a fluid call chain.</remarks>
        /// <typeparam name="TEntity">Type of the entity.</typeparam>
        /// <param name="query">      The query to act on.</param>
        /// <param name="parameter">  The parameter to filter by.</param>
<#      if (p.PropertyType == typeof(bool?)) { #>
        /// <param name="includeNull">If set, match the parameter even if it's null.</param>
<#      } #>
        /// <returns>The <see cref="IQueryable{TEntity}" /> with an additional Where applied if the parameter has a value.</returns>
        public static IQueryable<TEntity> Filter<#= pluralized #>By<#= p.Name #><TEntity>(
                this IQueryable<TEntity> query,
                bool? parameter<#=
                    p.PropertyType == typeof(bool?) ? ",\r\n                bool? includeNull" : string.Empty #>)
            where TEntity : class, I<#= theType.Name #>
        {
            if (<#= p.PropertyType == typeof(bool?) ? "includeNull != true && " : string.Empty #>!parameter.HasValue)
            {
                return query;
            }
            return Contract.RequiresNotNull(query)
                .Where(x => x.<#= p.Name #> == parameter);
        }
<#          } else if (p.PropertyType == typeof(Guid) || p.PropertyType == typeof(Guid?)) { #>
        /// <summary>An <see cref="IQueryable{TEntity}" /> extension method that filters records by the parameter (a Guid value).</summary>
        /// <remarks>Pass a parameter value of null to not filter by this in a fluid call chain.</remarks>
        /// <typeparam name="TEntity">Type of the entity.</typeparam>
        /// <param name="query">      The query to act on.</param>
        /// <param name="parameter">  The parameter to filter by.</param>
<#      if (p.PropertyType == typeof(Guid?)) { #>
        /// <param name="includeNull">If set, match the parameter even if it's null.</param>
<#      } #>
        /// <returns>The <see cref="IQueryable{TEntity}" /> with an additional Where applied if the parameter has a value.</returns>
        public static IQueryable<TEntity> Filter<#= pluralized #>By<#= p.Name #><TEntity>(
                this IQueryable<TEntity> query,
                Guid? parameter<#=
                    p.PropertyType == typeof(Guid?) ? ",\r\n                bool? includeNull" : string.Empty #>)
            where TEntity : class, I<#= theType.Name #>
        {
            if (<#= p.PropertyType == typeof(Guid?) ? "includeNull != true && " : string.Empty #>(parameter is null || parameter == default(Guid)))
            {
                return query;
            }
            return Contract.RequiresNotNull(query)
                .Where(x => x.<#= p.Name #> == parameter);
        }
<#          } else if ((p.PropertyType == typeof(int) || p.PropertyType == typeof(int?)) && p.Name.EndsWith("ID")) { #>
        /// <summary>An <see cref="IQueryable{TEntity}" /> extension method that filters records by the parameter (an identifier).</summary>
        /// <remarks>Pass a parameter value of null to not filter by this in a fluid call chain.</remarks>
        /// <typeparam name="TEntity">Type of the entity.</typeparam>
        /// <param name="query">      The query to act on.</param>
        /// <param name="parameter">  The parameter to filter by.</param>
<#      if (p.PropertyType == typeof(int?)) { #>
        /// <param name="includeNull">If set, match the parameter even if it's null.</param>
<#      } #>
        /// <returns>The <see cref="IQueryable{TEntity}" /> with an additional Where applied if the parameter has a value.</returns>
        public static IQueryable<TEntity> Filter<#= pluralized #>By<#= p.Name #><TEntity>(
                this IQueryable<TEntity> query,
                int? parameter<#=
                    p.PropertyType == typeof(int?) ? ",\r\n                bool? includeNull" : string.Empty #>)
            where TEntity : class, I<#= theType.Name #>
        {
            if (<#= p.PropertyType == typeof(int?) ? "includeNull != true && " : string.Empty #>Contract.CheckInvalidID(parameter))
            {
                return query;
            }
            return Contract.RequiresNotNull(query)
                .Where(x => x.<#= p.Name #> == parameter);
        }
<#          } else if (p.PropertyType == typeof(string)/* || p.PropertyType == typeof(string?)*/) { #>
        /// <summary>An <see cref="IQueryable{TEntity}" /> extension method that filters records by the parameter (an identifier).</summary>
        /// <remarks>Pass a parameter value of null to not filter by this in a fluid call chain.</remarks>
        /// <typeparam name="TEntity">Type of the entity.</typeparam>
        /// <param name="query">      The query to act on.</param>
        /// <param name="parameter">  The parameter to filter by.</param>
        /// <param name="strict">     If set, must match the string exactly (false or null will use a Contains/LIKE).</param>
<#      if (/*p.PropertyType == typeof(string?)*/true) { #>
        /// <param name="includeNull">If set, match the parameter even if it's null.</param>
<#      } #>
        /// <returns>The <see cref="IQueryable{TEntity}" /> with an additional Where applied if the parameter has a value.</returns>
        public static IQueryable<TEntity> Filter<#= pluralized #>By<#= p.Name #><TEntity>(
                this IQueryable<TEntity> query,
                string? parameter,
                bool? strict<#=
                    /*p.PropertyType == typeof(string?)*/true ? ",\r\n                bool? includeNull" : string.Empty #>)
            where TEntity : class, I<#= theType.Name #>
        {
            if (<#= /*p.PropertyType == typeof(string?)*/true ? "includeNull != true && " : string.Empty #>!Contract.CheckValidKey(parameter))
            {
                return query;
            }
            var search = parameter?.Trim();
            if (strict == true)
            {
                return Contract.RequiresNotNull(query)
                    .Where(x => x.<#= p.Name #> == search);
            }
            if (includeNull == true && !Contract.CheckValidKey(search))
            {
                return Contract.RequiresNotNull(query)
                    .Where(x => x.<#= p.Name #> == null || x.<#= p.Name #> == string.Empty);
            }
            search = search!.ToLower();
            return Contract.RequiresNotNull(query)
                .Where(x => x.<#= p.Name #> != null && x.<#= p.Name #>.Contains(search));
        }
<#          } else if (p.PropertyType == typeof(int) || p.PropertyType == typeof(int?)) { #>
        /// <summary>An <see cref="IQueryable{TEntity}" /> extension method that filters records by the parameter (a minimum integer value).</summary>
        /// <remarks>Pass a parameter value of null to not filter by this in a fluid call chain.</remarks>
        /// <typeparam name="TEntity">Type of the entity.</typeparam>
        /// <param name="query">      The query to act on.</param>
        /// <param name="parameter">  The parameter to filter by.</param>
        /// <returns>The <see cref="IQueryable{TEntity}" /> with an additional Where applied if the parameter has a value.</returns>
        public static IQueryable<TEntity> Filter<#= pluralized #>ByMin<#= p.Name #><TEntity>(
                this IQueryable<TEntity> query,
                int? parameter)
            where TEntity : class, I<#= theType.Name #>
        {
            if (!parameter.HasValue)
            {
                return query;
            }
            return Contract.RequiresNotNull(query)
                .Where(x => x.<#= p.Name #> >= parameter);
        }

        /// <summary>An <see cref="IQueryable{TEntity}" /> extension method that filters records by the parameter (a maximum integer value).</summary>
        /// <remarks>Pass a parameter value of null to not filter by this in a fluid call chain.</remarks>
        /// <typeparam name="TEntity">Type of the entity.</typeparam>
        /// <param name="query">      The query to act on.</param>
        /// <param name="parameter">  The parameter to filter by.</param>
        /// <returns>The <see cref="IQueryable{TEntity}" /> with an additional Where applied if the parameter has a value.</returns>
        public static IQueryable<TEntity> Filter<#= pluralized #>ByMax<#= p.Name #><TEntity>(
                this IQueryable<TEntity> query,
                int? parameter)
            where TEntity : class, I<#= theType.Name #>
        {
            if (!parameter.HasValue)
            {
                return query;
            }
            return Contract.RequiresNotNull(query)
                .Where(x => x.<#= p.Name #> <= parameter);
        }

        /// <summary>An <see cref="IQueryable{TEntity}" /> extension method that filters records by the parameter (a integer value to match).</summary>
        /// <remarks>Pass a parameter value of null to not filter by this in a fluid call chain.</remarks>
        /// <typeparam name="TEntity">Type of the entity.</typeparam>
        /// <param name="query">      The query to act on.</param>
        /// <param name="parameter">  The parameter to filter by.</param>
<#      if (p.PropertyType == typeof(int?)) { #>
        /// <param name="includeNull">If set, match the parameter even if it's null.</param>
<#      } #>
        /// <returns>The <see cref="IQueryable{TEntity}" /> with an additional Where applied if the parameter has a value.</returns>
        public static IQueryable<TEntity> Filter<#= pluralized #>ByMatch<#= p.Name #><TEntity>(
                this IQueryable<TEntity> query,
                int? parameter<#=
                    p.PropertyType == typeof(int?) ? ",\r\n                bool? includeNull" : string.Empty #>)
            where TEntity : class, I<#= theType.Name #>
        {
            if (<#= p.PropertyType == typeof(int?) ? "includeNull != true && " : string.Empty #>Contract.CheckInvalidID(parameter))
            {
                return query;
            }
            return Contract.RequiresNotNull(query)
                .Where(x => x.<#= p.Name #> == parameter);
        }
<#          } else { #>
        /// <summary>An <see cref="IQueryable{TEntity}" /> extension method that filters records by the parameter.</summary>
        /// <remarks>Pass a parameter value of null to not filter by this in a fluid call chain.</remarks>
        /// <typeparam name="TEntity">Type of the entity.</typeparam>
        /// <param name="query">    The query to act on.</param>
        /// <param name="parameter">The parameter to filter by.</param>
        /// <returns>The <see cref="IQueryable{TEntity}" /> with an additional Where applied if the parameter has a value.</returns>
        public static IQueryable<TEntity> Filter<#= pluralized #>By<#= p.Name #><TEntity>(
                this IQueryable<TEntity> query,
                <#= HelpFunctions.IsSimpleType(p.PropertyType)
                    ? HelpFunctions.SwapToSimpleType(p.PropertyType.Name)
                    : HelpFunctions.SwapToModelType(p.PropertyType.Name) #>? parameter)
            where TEntity : class, I<#= theType.Name #>
        {
            if (Contract.CheckInvalidID(parameter))
            {
                return query;
            }
            return Contract.RequiresNotNull(query)
                .Where(x => x.<#= p.Name #> == parameter.Value);
        }
<#          } #>
        #endregion
<#      } #>
    }
}
<#      SaveOutput(@group.Key + "\\" + theType.Name, "generated.cs", true);
    }
}
DeleteOldOutputs();
#>
