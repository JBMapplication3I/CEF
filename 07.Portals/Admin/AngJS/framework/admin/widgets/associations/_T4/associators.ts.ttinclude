<#@ assembly name="System.Core" #><#@
assembly name="System.Web.dll" #><#@
import namespace="System" #><#@
import namespace="System.Collections.Generic" #><#@
import namespace="System.Linq" #><#@
import namespace="System.Reflection" #><#@
import namespace="System.Runtime.InteropServices" #><#@
import namespace="Clarity.Ecommerce.DataModel" #><#@
import namespace="Clarity.Ecommerce.Interfaces.DataModel" #><#@
import namespace="ServiceStack" #><#@
import namespace="ServiceStack.CodeGenerator.TypeScript" #><#+
void GenerateAssociatorTypeScriptFile(Type theType, TypeDeterminer td, string schema, PropertyInfo property, IEnumerable<IGrouping<string, Type>> tableClasses)
{
	string lowerFirst = HelpFunctions.LowerFirstCharacter(theType.Name);
	string splitName = HelpFunctions.SplitCamelCase(theType.Name);
	string modelName = HelpFunctions.SwapToModelType(theType.Name);
	Type otherType = property.PropertyType.GetGenericArguments()[0];
	string otherModelName = HelpFunctions.SwapToModelType(otherType.Name);
	string otherTypeSchema = HelpFunctions.LowerFirstCharacter(tableClasses.First(x => x.Any(y => y.Name == otherType.Name)).Key).Replace("system", "structure");
	string otherTypeGetSingle = otherType.Name;
	string otherTypeGetList = HelpFunctions.PluralizeName(otherType.Name);
	TypeDeterminer otherTypeTD = new TypeDeterminer(otherType);
	Type associatedType = otherType.GetInterface("IAmARelationshipTable`2");
	if (associatedType == null)
	{
		return;
	}
	string[] otherTypePropertiesToSkip = new[] {
		"ID", "CustomKey", "CreatedDate", "UpdatedDate", "Active", "Hash", "JsonAttributes", "SerializableAttributes",
		"MasterID", "Master", "SlaveID", "Slave"
	};
	associatedType = associatedType.GetGenericArguments()[1];
	string associatedTypeModelName = HelpFunctions.SwapToModelType(associatedType.Name);
	List<string> processedVarNames = new List<string>();
	List<string> processedAltCalls = new List<string>();
	List<string> processedAltAssigns = new List<string>();
#>/**
 * @file framework/admin/widgets/associations/_T4/<#= lowerFirst #>.to.<#= property.Name #>.ts
 * @author Copyright (c) 2020-<#= DateTime.Today.Year #> clarity-ventures.com. All rights reserved.
 * @desc Associator for <#= splitName #> to <#= property.Name #> class
 * @auto-generated This file was auto-generated by the T4 template associators.tt in the UI project
 */
module cef.admin.widgets.associators.<#= schema #> {
	class AssociatorFor<#= theType.Name #>To<#= property.Name #>Controller extends core.TemplatedControllerBase {
		// Bound Scope Properties
		record: api.<#= modelName #>Model<#= otherType.Name.Contains("Item") && associatedType.Name == "Discount" ? "<api.AppliedDiscountBaseModel>" : string.Empty #>;
		ctrl: core.TemplatedControllerBase;
		// Properties
		propertyName: string = "<#= property.Name #>";
		paging: core.ServerSidePaging<api.<#= associatedTypeModelName #>Model, api.<#= associatedType.Name #>PagedResults>;
		assigned: core.ServerSidePaging<api.<#= otherModelName #>Model, api.<#= otherType.Name #>PagedResults>;
<#+		foreach (PropertyInfo p in otherType.GetProperties().Where(x => !otherTypePropertiesToSkip.Contains(x.Name) && x.Name != "FileAccessTypeID"
			&& x.CanRead && !x.HasAttribute<NotMappedAttribute>() && !x.HasAttribute<DontMapOutEverAttribute>() && !x.HasAttribute<DontMapInEverAttribute>() && x.Name != "noCache"
			&& (x.PropertyType == typeof(int?) || x.PropertyType == typeof(int)) && x.Name.EndsWith("ID")))
		{
			string altName = p.Name.Substring(0, p.Name.Length - 2);
			PropertyInfo altProperty = otherType.GetProperties().SingleOrDefault(x => x.Name == altName);
			string varName = HelpFunctions.LowerFirstCharacter(
				HelpFunctions.PluralizeName(altProperty == null ? "Bad" : altProperty.PropertyType.Name));
			if (processedVarNames.Contains(varName))
			{
				continue;
			}
			processedVarNames.Add(varName); #>
		<#= varName #>: api.<#= altProperty == null ? "Bad" : HelpFunctions.SwapToModelType(altProperty.PropertyType.Name) #>Model[];
<#+		} #>
		// Convenience Redirects
		// <None>
		// Functions
		load(): void {
			this.setRunning();
			const paging = <api.Paging>{ Size: 500, StartIndex: 1 };
			const standardDto = {
				Active: true,
				AsListing: true,
<#+				if (otherType.Name == "MessageRecipient") { #>
				IncludeChildrenInResults: false,
<#+				} #>
				Paging: paging
			};
			this.$q.all([
<#+		foreach (PropertyInfo p in otherType.GetProperties().Where(x => !otherTypePropertiesToSkip.Contains(x.Name) && x.Name != "FileAccessTypeID"
			&& x.CanRead && !x.HasAttribute<NotMappedAttribute>() && !x.HasAttribute<DontMapOutEverAttribute>() && !x.HasAttribute<DontMapInEverAttribute>() && x.Name != "noCache"
			&& (x.PropertyType == typeof(int?) || x.PropertyType == typeof(int)) && x.Name.EndsWith("ID")))
		{
			string altName = p.Name.Substring(0, p.Name.Length - 2);
			PropertyInfo altProperty = otherType.GetProperties().SingleOrDefault(x => x.Name == altName);
			IGrouping<string, Type> altGroup = altProperty == null ? null : tableClasses.FirstOrDefault(x => x.Any(y => y.Name == altProperty.PropertyType.Name));
			string altSchema = altGroup == null ? string.Empty : altGroup.Key;
			string altCall = altGroup == null ? string.Empty : HelpFunctions.PluralizeName(altProperty.PropertyType.Name);
			if (processedAltCalls.Contains(altCall))
			{
				continue;
			}
			processedAltCalls.Add(altCall); #>
				this.cvApi.<#= HelpFunctions.LowerFirstCharacter(altSchema) #>.Get<#= altCall #>(standardDto),
<#+		} #>
				this.$q.resolve(null)
			]).then((rarr: ng.IHttpPromiseCallbackArg<any>[]) => {
				let index = 0;
<#+		foreach (PropertyInfo p in otherType.GetProperties().Where(x => !otherTypePropertiesToSkip.Contains(x.Name) && x.Name != "FileAccessTypeID"
			&& x.CanRead && !x.HasAttribute<NotMappedAttribute>() && !x.HasAttribute<DontMapOutEverAttribute>() && !x.HasAttribute<DontMapInEverAttribute>() && x.Name != "noCache"
			&& (x.PropertyType == typeof(int?) || x.PropertyType == typeof(int)) && x.Name.EndsWith("ID")))
		{
			string altName = p.Name.Substring(0, p.Name.Length - 2);
			PropertyInfo altProperty = otherType.GetProperties().SingleOrDefault(x => x.Name == altName);
			string altAssign = HelpFunctions.LowerFirstCharacter(HelpFunctions.PluralizeName(
				altProperty == null ? "Bad" : altProperty.PropertyType.Name));
			if (processedAltAssigns.Contains(altAssign))
			{
				continue;
			}
			processedAltAssigns.Add(altAssign); #>
				this.<#= altAssign #> = rarr[index++].data.Results;
<#+		}
		IGrouping<string, Type> othGroup = tableClasses.FirstOrDefault(x => x.Any(y => y.Name == associatedType.Name)); #>
				this.paging = new core.ServerSidePaging<api.<#= associatedTypeModelName #>Model, api.<#= associatedType.Name #>PagedResults>(
					this.$rootScope,
					this.$scope,
					this.$filter,
					this.$q,
					this.cvServiceStrings,
					this.cvApi.<#= HelpFunctions.LowerFirstCharacter(othGroup.Key).Replace("system", "structure") #>.Get<#=
						HelpFunctions.PluralizeName(associatedType.Name) #>, 8, `<#= lowerFirst #>-${this.record && this.record.ID}.to.<#= property.Name #>.available`, <#=
						associatedType.Name == "User" ? "\"IDOrUserNameOrCustomKeyOrEmailOrContactName\"" : "null"
						#>,
					() => {
						return {
							Active: true,
							AsListing: true,
							__caller: `<#= lowerFirst #>-${this.record && this.record.ID}.to.<#= property.Name #>.available`
						};
					},
					() => !this.record || !this.record.ID);
				this.assigned = new core.ServerSidePaging<api.<#= otherModelName #>Model, api.<#= otherType.Name #>PagedResults>(
					this.$rootScope,
					this.$scope,
					this.$filter,
					this.$q,
					this.cvServiceStrings,
					this.cvApi.<#= otherTypeSchema #>.Get<#= otherTypeGetList #>, 8, `<#= lowerFirst #>-${this.record && this.record.ID}.to.<#= property.Name #>.assigned`, <#=
						otherType.Name == "User" ? "\"IDOrUserNameOrCustomKeyOrEmailOrContactName\"" : "null"
						#>,
					() => {
						return {
							Active: true,
							AsListing: true,
							MasterID: this.record && this.record.ID || 0,
							__caller: `<#= lowerFirst #>-${this.record && this.record.ID}.to.<#= property.Name #>.assigned`
						};
					},
					() => !this.record || !this.record.ID);
			}).finally(() => this.finishRunning());
		}
		add(id: number): void {
			if (!id) {
				return;
			}
			if (!this.record || !this.record.ID) {
				this.cvMessageModalFactory(this.$translate("ui.admin.associators.errors.YouMustSaveTheRecordFirst"))
					.finally(() => { /* Do Nothing */ });
				return;
			}
			// Ensure the data is loaded
			const model = _.find(this.paging.dataUnpaged, x => x.ID === id);
			if (!model) {
				return;
			}
			// Ensure it's not already in the collection
<#+ /* TODO@JTG: otherTypeTD.IsIHaveAType , add the TypeID to this find, but have to do an intermediate modal to ask for the type first */ #>
			if (_.find(this.assigned.dataUnpaged, x => x["SlaveID"] === model.ID)) {
				this.cvMessageModalFactory(this.$translate("ui.admin.associators.errors.ThisIsAlreadyInTheCollection"))
					.finally(() => { /* Do Nothing */ });
				return;
			}
			this.setRunning();
			const dupeCheckDto = {
				Active: true,
				AsListing: true,
				MasterID: this.record.ID,
				SlaveID: id,
<#+ /* TODO@JTG: otherTypeTD.IsIHaveAType , add the TypeID to this filter, but have to do an intermediate modal to ask for the type first */ #>
				"__caller": `<#= lowerFirst #>-${this.record && this.record.ID}.to.<#= property.Name #>.dupe-check`
			};
			this.cvApi.<#= otherTypeSchema #>.Get<#= otherTypeGetList #>(dupeCheckDto).then(r => {
				if (!r || !r.data || !r.data.Results) {
					this.cvMessageModalFactory(this.$translate("ui.admin.associators.errors.CouldNotRetrieveDataFromDuplicateCheck"))
						.finally(() =>
							this.finishRunning(true, this.$translate("ui.admin.associators.errors.CouldNotRetrieveDataFromDuplicateCheck")));
					return;
				}
				if (r.data.Results.length) {
					this.cvMessageModalFactory(this.$translate("ui.admin.associators.errors.ThisIsAlreadyInTheCollection"))
						.finally(() =>
							this.finishRunning(true, this.$translate("ui.admin.associators.errors.ThisIsAlreadyInTheCollection")));
					return;
				}
				// Add it
				this.cvApi.<#= otherTypeSchema #>.Create<#= otherTypeGetSingle #>(<api.<#= otherModelName #>Model>{
					// Base Properties
					ID: null,
					Active: true,
					CreatedDate: new Date(),
					MasterID: this.record.ID,
					SlaveID: model.ID,
<#+				bool first = true; #>
<#+				foreach (PropertyInfo p in otherType.GetProperties().Where(x => !otherTypePropertiesToSkip.Contains(x.Name))) { #>
<#+					if (first) { first = false; #>
					// <#= otherType.Name #> Properties
<#+					} #>
					<#= p.Name #>: <#= p.PropertyType.Name == "Boolean" ? "false" : p.PropertyType.Name == "Int32" ? "0" : "null" #>,
<#+				} #>
				}).then(rc => {
					if (!rc || !rc.data) {
						this.finishRunning(true, "ERROR! Failed to create the association in the server");
						return;
					}
					if (this.record[this.propertyName]) {
						this.record[this.propertyName] = null; // Ensure we are only setting the new way
					}
					this.assigned.resetAll(); // Pull updated data
					this.assigned.search(); // Pull updated data
					// this.forms[this.propertyName].$setDirty();
					this.finishRunning();
				}).catch(reason => this.finishRunning(true, reason));
			}).catch(reason => this.finishRunning(true, reason));
		}
<#+ /* TODO@JTG: otherType may have additional properties to set, if it does we need to call an update function */ #>
		remove(toRemove: api.<#= otherModelName #>Model): void {
			this.cvConfirmModalFactory(
				this.$translate("ui.admin.common.AreYouSureYouWantToRemoveThisAssociation.Question")
			).then(result => {
				if (!result) {
					return;
				}
				this.cvApi.<#= otherTypeSchema #>.Deactivate<#= otherTypeGetSingle #>ByID(toRemove.ID).then(r => {
					if (!r || !r.data) {
						this.finishRunning(true, "ERROR! Failed to disassociate the record in the server.");
						return;
					}
					if (this.record[this.propertyName]) {
						this.record[this.propertyName] = null; // Ensure we are only setting the new way
					}
					this.assigned.resetAll(); // Pull updated data
					this.assigned.search(); // Pull updated data
					// this.forms[this.propertyName].$setDirty();
					this.cvMessageModalFactory(this.$translate("ui.admin.associators.success.TheRecordHasBeenDisassociatedOnTheServer"))
						.finally(() => this.finishRunning());
				}).catch(reason => this.finishRunning(true, reason));
				/*
				for (let i = 0; i < this.record[this.propertyName].length; i++) {
					if (toRemove === this.record[this.propertyName][i]) {
						this.record[this.propertyName].splice(i, 1);
						this.forms[this.propertyName].$setDirty();
						return;
					}
				}
				*/
			});
		}
		// Events
		// <None>
		// Constructor
		constructor(
				private readonly $rootScope: ng.IRootScopeService,
				private readonly $scope: ng.IScope,
				private readonly $translate: ng.translate.ITranslateService,
				private readonly $q: ng.IQService,
				private readonly $filter: ng.IFilterService,
				protected readonly cefConfig: core.CefConfig,
				private readonly cvServiceStrings: services.IServiceStrings,
				private readonly cvApi: api.ICEFAPI,
				private readonly cvMessageModalFactory: modals.IMessageModalFactory,
				private readonly cvConfirmModalFactory: modals.IConfirmModalFactory) {
			super(cefConfig);
			this.load();
		}
	}

	adminApp.directive("cef<#= theType.Name #>To<#= property.Name #>Associator", ($filter: ng.IFilterService): ng.IDirective => ({
		restrict: "A",
		scope: {
			record: "=",
			ctrl: "="
		},
		templateUrl: $filter("corsLink")("/framework/admin/widgets/associations/_T4/<#=
			HelpFunctions.PluralizeName(lowerFirst) #>.to.<#= property.Name #>.html", "ui"),
		controller: AssociatorFor<#= theType.Name #>To<#= property.Name #>Controller,
		controllerAs: "asCtrl",
		bindToController: true
	}));
}
<#+
} // End Function GenerateAssociatorTypeScriptFile
#>