// <autogenerated>
// <copyright file="StoreWorkflow.generated.cs" company="clarity-ventures.com">
// Copyright (c) 2016-2023 clarity-ventures.com. All rights reserved.
// </copyright>
// <summary>Implements the Workflow generated to provide base setups</summary>
// <remarks>This file was auto-generated by Workflows.tt, changes to this
// file will be overwritten automatically when the T4 template is run again</remarks>
// </autogenerated>
#nullable enable
// ReSharper disable ConvertToUsingDeclaration, InvertIf, ReturnValueOfPureMethodIsNotUsed, UnusedMember.Local
#pragma warning disable CS0618,CS1711,CS1572,CS1580,CS1581,CS1584
namespace Clarity.Ecommerce.Workflow
{
    using System;
    using System.Collections.Generic;
    using System.Data.Entity;
    using System.Linq;
    using System.Threading.Tasks;
    using DataModel;
    using Interfaces.DataModel;
    using Interfaces.Models;
    using Interfaces.Workflow;
    using Mapper;
    using Utilities;

    /// <summary>A workflow for Store entities.</summary>
    /// <seealso cref="NameableWorkflowBase{IStoreModel, IStoreSearchModel, IStore, Store}"/>
    /// <seealso cref="IStoreWorkflow"/>
    public partial class StoreWorkflow
        : NameableWorkflowBase<IStoreModel, IStoreSearchModel, IStore, Store>
            , IStoreWorkflow
    {
        #region Mappers
        /// <inheritdoc/>
        protected override Func<Store?, string?, IStoreModel?> MapFromConcreteFull
            => ModelMapperForStore.MapStoreModelFromEntityFull;

        /// <inheritdoc/>
        protected override Func<IQueryable<Store>, string?, IEnumerable<IStoreModel>> SelectLiteAndMapToModel
            => ModelMapperForStore.SelectLiteStoreAndMapToStoreModel;

        /// <inheritdoc/>
        protected override Func<IQueryable<Store>, string?, IEnumerable<IStoreModel>> SelectListAndMapToModel
            => ModelMapperForStore.SelectListStoreAndMapToStoreModel;

        /// <inheritdoc/>
        protected override Func<IQueryable<Store>, string?, IStoreModel?> SelectFirstFullAndMapToModel
            => ModelMapperForStore.SelectFirstFullStoreAndMapToStoreModel;

        /// <inheritdoc/>
        protected override Func<IStore, IStoreModel, DateTime, DateTime?, IStore> UpdateEntityFromModel
            => ModelMapperForStore.UpdateStoreFromModel;
        #endregion

        /// <inheritdoc/>
        public virtual async Task<DateTime?> GetLastModifiedForBySeoUrlResultAsync(string seoUrl, string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            return await GetLastModifiedForBySeoUrlResultAsync(seoUrl, context).ConfigureAwait(false);
        }

        /// <inheritdoc/>
        public virtual async Task<DateTime?> GetLastModifiedForBySeoUrlResultAsync(string seoUrl, IClarityEcommerceEntities context)
        {
            return await context.Set<Store>()
                .AsNoTracking()
                .FilterBySeoUrl(Contract.RequiresValidKey(seoUrl), true, false)
                .Select(x => x.UpdatedDate ?? x.CreatedDate)
                .SingleOrDefaultAsync()
                .ConfigureAwait(false);
        }

        /// <inheritdoc/>
        public virtual async Task<IStoreModel?> GetBySeoUrlAsync(
            string seoUrl,
            string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            return await GetBySeoUrlAsync(seoUrl, context).ConfigureAwait(false);
        }

        /// <inheritdoc/>
        public virtual Task<IStoreModel?> GetBySeoUrlAsync(
            string seoUrl,
            IClarityEcommerceEntities context)
        {
            return Task.FromResult(
                SelectFirstFullAndMapToModel(
                    context.Set<Store>()
                        .AsNoTracking()
                        .FilterBySeoUrl(Contract.RequiresValidKey(seoUrl), true, false),
                    context.ContextProfileName));
        }

        /// <inheritdoc/>
        public virtual async Task<int?> CheckExistsBySeoUrlAsync(string seoUrl, string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            return await CheckExistsBySeoUrlAsync(seoUrl, context).ConfigureAwait(false);
        }

        /// <inheritdoc/>
        public virtual Task<int?> CheckExistsBySeoUrlAsync(string seoUrl, IClarityEcommerceEntities context)
        {
            return context.Set<Store>()
                .FilterByActive(true)
                .FilterBySeoUrl(Contract.RequiresValidKey(seoUrl), true, false)
                .Select(x => (int?)x.ID)
                .SingleOrDefaultAsync();
        }

        /// <summary>Gets entity by SEO URL.</summary>
        /// <param name="seoUrl"> URL of the SEO.</param>
        /// <param name="context">The context.</param>
        /// <returns>The entity by SEO URL.</returns>
        protected virtual Task<Store> GetEntityBySeoUrlAsync(
            string seoUrl,
            IClarityEcommerceEntities context)
        {
            return context.Set<Store>()
                .FilterByActive(true)
                .FilterBySeoUrl(Contract.RequiresValidKey(seoUrl), true, false)
                .SingleOrDefaultAsync();
        }

        /// <inheritdoc/>
        protected override async Task<IQueryable<Store>> FilterQueryByModelExtensionAsync(
            IQueryable<Store> query,
            IStoreSearchModel search,
            IClarityEcommerceEntities context)
        {
            return (await base.FilterQueryByModelExtensionAsync(query, search, context).ConfigureAwait(false))
                .FilterStoresBySearchModel(search);
        }

        /// <inheritdoc/>
        protected override async Task RunDefaultAssociateWorkflowsAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            await RunDefaultAssociateWorkflowsAsync(entity, model, timestamp, context).ConfigureAwait(false);
        }

        /// <inheritdoc/>
        protected override async Task RunDefaultAssociateWorkflowsAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            IClarityEcommerceEntities context)
        {
            await Workflows.AssociateJsonAttributes.AssociateObjectsAsync(entity, model, context).ConfigureAwait(false);
            SetDefaultJsonAttributesIfNull(entity);
            if (model.Notes != null)
            {
                if (Contract.CheckValidID(entity.ID))
                {
                    foreach (var note in model.Notes)
                    {
                        note.StoreID = entity.ID;
                    }
                }
                await Workflows.StoreWithNotesAssociation.AssociateObjectsAsync(entity, model, timestamp, context).ConfigureAwait(false);
            }
            if (model.Images != null) { await Workflows.StoreWithImagesAssociation.AssociateObjectsAsync(entity, model, timestamp, context).ConfigureAwait(false); }
            if (model.Reviews != null) { await Workflows.StoreWithReviewsAssociation.AssociateObjectsAsync(entity, model, timestamp, context).ConfigureAwait(false); }
            if (model.Products != null) { await Workflows.StoreWithProductsAssociation.AssociateObjectsAsync(entity, model, timestamp, context).ConfigureAwait(false); }
            if (model.Accounts != null) { await Workflows.StoreWithAccountsAssociation.AssociateObjectsAsync(entity, model, timestamp, context).ConfigureAwait(false); }
            if (model.Users != null) { await Workflows.StoreWithUsersAssociation.AssociateObjectsAsync(entity, model, timestamp, context).ConfigureAwait(false); }
            if (model.Vendors != null) { await Workflows.StoreWithVendorsAssociation.AssociateObjectsAsync(entity, model, timestamp, context).ConfigureAwait(false); }
            if (model.Categories != null) { await Workflows.StoreWithCategoriesAssociation.AssociateObjectsAsync(entity, model, timestamp, context).ConfigureAwait(false); }
            if (model.Brands != null) { await Workflows.StoreWithBrandsAssociation.AssociateObjectsAsync(entity, model, timestamp, context).ConfigureAwait(false); }
            if (model.Franchises != null) { await Workflows.StoreWithFranchisesAssociation.AssociateObjectsAsync(entity, model, timestamp, context).ConfigureAwait(false); }
            if (model.Manufacturers != null) { await Workflows.StoreWithManufacturersAssociation.AssociateObjectsAsync(entity, model, timestamp, context).ConfigureAwait(false); }
            if (model.StoreBadges != null) { await Workflows.StoreWithStoreBadgesAssociation.AssociateObjectsAsync(entity, model, timestamp, context).ConfigureAwait(false); }
            if (model.StoreContacts != null) { await Workflows.StoreWithStoreContactsAssociation.AssociateObjectsAsync(entity, model, timestamp, context).ConfigureAwait(false); }
            if (model.StoreInventoryLocations != null) { await Workflows.StoreWithStoreInventoryLocationsAssociation.AssociateObjectsAsync(entity, model, timestamp, context).ConfigureAwait(false); }
            if (model.StoreSubscriptions != null) { await Workflows.StoreWithStoreSubscriptionsAssociation.AssociateObjectsAsync(entity, model, timestamp, context).ConfigureAwait(false); }
            if (model.StoreCountries != null) { await Workflows.StoreWithStoreCountriesAssociation.AssociateObjectsAsync(entity, model, timestamp, context).ConfigureAwait(false); }
            if (model.StoreRegions != null) { await Workflows.StoreWithStoreRegionsAssociation.AssociateObjectsAsync(entity, model, timestamp, context).ConfigureAwait(false); }
            if (model.StoreDistricts != null) { await Workflows.StoreWithStoreDistrictsAssociation.AssociateObjectsAsync(entity, model, timestamp, context).ConfigureAwait(false); }
        }

        #region Relate Workflows
        /// <summary>Relate Required Type.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">            The entity that has a Required Type.</param>
        /// <param name="model">             The model that has a Required Type.</param>
        /// <param name="timestamp">         The timestamp Date/Time.</param>
        /// <param name="contextProfileName">Name of the context profile.</param>
        protected virtual async Task RelateRequiredTypeAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            await RelateRequiredTypeAsync(
                    entity,
                    model,
                    timestamp,
                    context)
                .ConfigureAwait(false);
        }

        /// <summary>Relate Required Type.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">   The entity that has a Required Type.</param>
        /// <param name="model">    The model that has a Required Type.</param>
        /// <param name="timestamp">The timestamp Date/Time.</param>
        /// <param name="context">  The context.</param>
        // ReSharper disable once CyclomaticComplexity, CognitiveComplexity
        protected virtual async Task RelateRequiredTypeAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            IClarityEcommerceEntities context)
        {
            // Must have the core objects on both sides
            Contract.RequiresNotNull(entity);
            Contract.RequiresNotNull(model);
            // Look up the Object Model
            // Allowed to auto-generate if not found
            var resolved = await Workflows.StoreTypes.ResolveWithAutoGenerateOptionalAsync(
                    byID: model.TypeID, // By Other ID
                    byKey: model.TypeKey, // By Flattened Other Key
                    byName: model.TypeName, // By Flattened Other Name
                    byDisplayName: null, // Skip DisplayName as it's not normally part of the interface
                    model: model.Type, // The other property as a model
                    context: context)
                .ConfigureAwait(false);
            // Check for IDs and objects
            var entityIDIsNull = !Contract.CheckValidID(entity.TypeID);
            var modelIDIsNull = !Contract.CheckValidID(resolved.Result?.ID);
            var entityObjectIsNull = entity.Type == null;
            if (!resolved.ActionSucceeded && model.Type != null)
            {
                resolved.Result = model.Type;
            }
            var modelObjectIsNull = !resolved.ActionSucceeded;
            if (modelIDIsNull && modelObjectIsNull)
            {
                // [Required] Scenario 1: Trying to put bad data in the database
                throw new ArgumentException("Cannot assign a null to a non-nullable TypeID");
            }
            var entityIDAndModelIDHaveSameID = !entityIDIsNull && !modelIDIsNull && entity.TypeID == resolved.Result!.ID;
            var entityObjectAndModelObjectHaveSameID = !entityObjectIsNull && !modelObjectIsNull && entity.TypeID == resolved.Result!.ID;
            if (entityIDAndModelIDHaveSameID || entityObjectAndModelObjectHaveSameID)
            {
                // [Optional/Required] Scenario 2: They match IDs, just update the entity from the model if it is present
                if (!entityObjectIsNull && !modelObjectIsNull)
                {
                    entity.Type!.UpdateStoreTypeFromModel(resolved.Result!, timestamp, timestamp);
                }
                return;
            }
            if (!modelIDIsNull)
            {
                // [Optional/Required] Scenario 3: We have IDs but they don't match, assign the model's ID to the entity's ID
                entity.TypeID = resolved.Result!.ID;
                if (!modelObjectIsNull)
                {
                    if (!entityObjectIsNull)
                    {
                        // [Optional/Required] Scenario 3a: We can't update the existing object because it's the wrong one
                    }
                    else
                    {
                        // [Optional/Required] Scenario 3b: We can't assign a new object in on this entity because it would duplicate the record
                    }
                }
                return;
            }
            var modelObjectIDIsNull = !modelObjectIsNull && !Contract.CheckValidID(resolved.Result!.ID);
            var modelObjectIsActive = !modelObjectIsNull && resolved.Result!.Active;
            if (!modelObjectIDIsNull && !modelObjectIsActive)
            {
                // [Required] Scenario 4: We have an ID on the model, but the object is inactive
                throw new InvalidOperationException("Cannot assign an inactive TypeID to the Store entity");
            }
            if (!modelObjectIDIsNull)
            {
                // [Required] Scenario 5: We have IDs but they don't match, assign the model's ID to the entity's ID (from the model object)
                entity.TypeID = resolved.Result!.ID;
                return;
            }
            if (modelObjectIsActive)
            {
                // [Required] Scenario 7: We have an entity id, but a new model, remove the id on the entity and assign the new model
                entity.TypeID = 0;
                entity.Type = (StoreType)resolved.Result!.CreateStoreTypeEntity(timestamp, context.ContextProfileName);
                return;
            }
            // [Required] Scenarios 8,9 are only for Optional relationships, skipped
            // [Optional/Required] Scenario 10: Could not figure out what to do
            throw new InvalidOperationException(
                "Couldn't figure out how to relate the given Type to the Store entity");
        }

        /// <summary>Relate Optional Contact.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">            The entity that has a Optional Contact.</param>
        /// <param name="model">             The model that has a Optional Contact.</param>
        /// <param name="timestamp">         The timestamp Date/Time.</param>
        /// <param name="contextProfileName">Name of the context profile.</param>
        protected virtual async Task RelateOptionalContactAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            await RelateOptionalContactAsync(
                    entity,
                    model,
                    timestamp,
                    context)
                .ConfigureAwait(false);
        }

        /// <summary>Relate Optional Contact.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">   The entity that has a Optional Contact.</param>
        /// <param name="model">    The model that has a Optional Contact.</param>
        /// <param name="timestamp">The timestamp Date/Time.</param>
        /// <param name="context">  The context.</param>
        // ReSharper disable once CyclomaticComplexity, CognitiveComplexity
        protected virtual async Task RelateOptionalContactAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            IClarityEcommerceEntities context)
        {
            // Must have the core objects on both sides
            Contract.RequiresNotNull(entity);
            Contract.RequiresNotNull(model);
            // Look up the Object Model
            // Allowed to auto-generate if not found
            var resolved = await Workflows.Contacts.ResolveWithAutoGenerateOptionalAsync(
                    byID: model.ContactID, // By Other ID
                    byKey: model.ContactKey, // By Flattened Other Key
                    model: model.Contact, // The other property as a model
                    context: context)
                .ConfigureAwait(false);
            // Check for IDs and objects
            var entityIDIsNull = !Contract.CheckValidID(entity.ContactID);
            var modelIDIsNull = !Contract.CheckValidID(resolved.Result?.ID);
            var entityObjectIsNull = entity.Contact == null;
            if (!resolved.ActionSucceeded && model.Contact != null)
            {
                resolved.Result = model.Contact;
            }
            var modelObjectIsNull = !resolved.ActionSucceeded;
            if (entityIDIsNull && modelIDIsNull && entityObjectIsNull && modelObjectIsNull)
            {
                // [Optional] Scenario 1: Nothing we can do with/to either end, so do nothing
                return;
            }
            var entityIDAndModelIDHaveSameID = !entityIDIsNull && !modelIDIsNull && entity.ContactID == resolved.Result!.ID;
            var entityObjectAndModelObjectHaveSameID = !entityObjectIsNull && !modelObjectIsNull && entity.ContactID == resolved.Result!.ID;
            if (entityIDAndModelIDHaveSameID || entityObjectAndModelObjectHaveSameID)
            {
                // [Optional/Required] Scenario 2: They match IDs, just update the entity from the model if it is present
                if (!entityObjectIsNull && !modelObjectIsNull)
                {
                    entity.Contact!.UpdateContactFromModel(resolved.Result!, timestamp, timestamp);
                    // Update the Address Properties as well if available
                    if (model.Contact?.Address != null)
                    {
                        if (entity.Contact!.Address == null)
                        {
                            entity.Contact.Address = (Address)model.Contact.Address.CreateAddressEntity(timestamp, context.ContextProfileName);
                        }
                        else
                        {
                            entity.Contact.Address.UpdateAddressFromModel(model.Contact.Address, timestamp, timestamp);
                        }
                    }
                }
                return;
            }
            if (!modelIDIsNull)
            {
                // [Optional/Required] Scenario 3: We have IDs but they don't match, assign the model's ID to the entity's ID
                entity.ContactID = resolved.Result!.ID;
                if (!modelObjectIsNull)
                {
                    if (!entityObjectIsNull)
                    {
                        // [Optional/Required] Scenario 3a: We can't update the existing object because it's the wrong one
                    }
                    else
                    {
                        // [Optional/Required] Scenario 3b: We can't assign a new object in on this entity because it would duplicate the record
                    }
                }
                return;
            }
            var modelObjectIDIsNull = !modelObjectIsNull && !Contract.CheckValidID(resolved.Result!.ID);
            var modelObjectIsActive = !modelObjectIsNull && resolved.Result!.Active;
            if (!modelObjectIsNull && !modelObjectIDIsNull)
            {
                if (modelObjectIsActive)
                {
                    // [Optional] Scenario 4: We have IDs but they don't match, assign the model's ID to the entity's ID (from the model object)
                    entity.ContactID = resolved.Result!.ID;
                    return;
                }
                // [Optional] Scenario 5: We have IDs but they don't match and the model has been deactivated, remove the entity from it's master
                entity.ContactID = null;
                entity.Contact = null;
                return;
            }
            if (!entityIDIsNull && modelObjectIsActive)
            {
                // [Optional] Scenario 6: We have an entity id, but a new model, remove the id on the entity and assign the new model
                entity.ContactID = null;
                entity.Contact = (Contact)resolved.Result!.CreateContactEntity(timestamp, context.ContextProfileName);
                return;
            }
            if (entityIDIsNull && modelObjectIsActive)
            {
                // [Optional] Scenario 7: We don't have an entity id, and we have a new model, assign the new model
                entity.Contact = (Contact)resolved.Result!.CreateContactEntity(timestamp, context.ContextProfileName);
                return;
            }
            if (!entityIDIsNull && modelIDIsNull && !modelObjectIsActive)
            {
                // [Optional] Scenario 8: We were removing or deactivating the object, clear it from the entity
                entity.ContactID = null;
                entity.Contact = null;
                return;
            }
            // Note: We would do this if it wasn't just a base typable entity (like ReportType, which has extra values to adjust on the model)
            // if (!entityObjectIsNull && modelObjectIsActive && entityObjectAndModelObjectHaveSameID)
            // {
            //     // TODO: Determine 'Equals' object between the objects so we only update if different
            //     // [Optional] Scenario 9: We have data on both sides, update the object, assign the values using the Update action
            //     entity.Contact.UpdateContactFromModel(resolved.Result, updateTimestamp);
            //     return;
            // }
            // [Optional/Required] Scenario 10: Could not figure out what to do
            throw new InvalidOperationException(
                "Couldn't figure out how to relate the given Contact to the Store entity");
        }

        /// <summary>Relate Optional MinimumOrderDollarAmountBufferProduct.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">            The entity that has a Optional MinimumOrderDollarAmountBufferProduct.</param>
        /// <param name="model">             The model that has a Optional MinimumOrderDollarAmountBufferProduct.</param>
        /// <param name="timestamp">         The timestamp Date/Time.</param>
        /// <param name="contextProfileName">Name of the context profile.</param>
        protected virtual async Task RelateOptionalMinimumOrderDollarAmountBufferProductAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            await RelateOptionalMinimumOrderDollarAmountBufferProductAsync(
                    entity,
                    model,
                    timestamp,
                    context)
                .ConfigureAwait(false);
        }

        /// <summary>Relate Optional MinimumOrderDollarAmountBufferProduct.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">   The entity that has a Optional MinimumOrderDollarAmountBufferProduct.</param>
        /// <param name="model">    The model that has a Optional MinimumOrderDollarAmountBufferProduct.</param>
        /// <param name="timestamp">The timestamp Date/Time.</param>
        /// <param name="context">  The context.</param>
        // ReSharper disable once CyclomaticComplexity, CognitiveComplexity
        protected virtual async Task RelateOptionalMinimumOrderDollarAmountBufferProductAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            IClarityEcommerceEntities context)
        {
            // Must have the core objects on both sides
            Contract.RequiresNotNull(entity);
            Contract.RequiresNotNull(model);
            // Look up the Object Model
            // Allowed to auto-generate if not found
            var resolved = await Workflows.Products.ResolveWithAutoGenerateOptionalAsync(
                    byID: model.MinimumOrderDollarAmountBufferProductID, // By Other ID
                    byKey: model.MinimumOrderDollarAmountBufferProductKey, // By Flattened Other Key
                    byName: model.MinimumOrderDollarAmountBufferProductName, // By Flattened Other Name
                    model: model.MinimumOrderDollarAmountBufferProduct, // The other property as a model
                    context: context)
                .ConfigureAwait(false);
            // Check for IDs and objects
            var entityIDIsNull = !Contract.CheckValidID(entity.MinimumOrderDollarAmountBufferProductID);
            var modelIDIsNull = !Contract.CheckValidID(resolved.Result?.ID);
            var entityObjectIsNull = entity.MinimumOrderDollarAmountBufferProduct == null;
            if (!resolved.ActionSucceeded && model.MinimumOrderDollarAmountBufferProduct != null)
            {
                resolved.Result = model.MinimumOrderDollarAmountBufferProduct;
            }
            var modelObjectIsNull = !resolved.ActionSucceeded;
            if (entityIDIsNull && modelIDIsNull && entityObjectIsNull && modelObjectIsNull)
            {
                // [Optional] Scenario 1: Nothing we can do with/to either end, so do nothing
                return;
            }
            var entityIDAndModelIDHaveSameID = !entityIDIsNull && !modelIDIsNull && entity.MinimumOrderDollarAmountBufferProductID == resolved.Result!.ID;
            var entityObjectAndModelObjectHaveSameID = !entityObjectIsNull && !modelObjectIsNull && entity.MinimumOrderDollarAmountBufferProductID == resolved.Result!.ID;
            if (entityIDAndModelIDHaveSameID || entityObjectAndModelObjectHaveSameID)
            {
                // [Optional/Required] Scenario 2: They match IDs, just update the entity from the model if it is present
                if (!entityObjectIsNull && !modelObjectIsNull)
                {
                    entity.MinimumOrderDollarAmountBufferProduct!.UpdateProductFromModel(resolved.Result!, timestamp, timestamp);
                }
                return;
            }
            if (!modelIDIsNull)
            {
                // [Optional/Required] Scenario 3: We have IDs but they don't match, assign the model's ID to the entity's ID
                entity.MinimumOrderDollarAmountBufferProductID = resolved.Result!.ID;
                if (!modelObjectIsNull)
                {
                    if (!entityObjectIsNull)
                    {
                        // [Optional/Required] Scenario 3a: We can't update the existing object because it's the wrong one
                    }
                    else
                    {
                        // [Optional/Required] Scenario 3b: We can't assign a new object in on this entity because it would duplicate the record
                    }
                }
                return;
            }
            var modelObjectIDIsNull = !modelObjectIsNull && !Contract.CheckValidID(resolved.Result!.ID);
            var modelObjectIsActive = !modelObjectIsNull && resolved.Result!.Active;
            if (!modelObjectIsNull && !modelObjectIDIsNull)
            {
                if (modelObjectIsActive)
                {
                    // [Optional] Scenario 4: We have IDs but they don't match, assign the model's ID to the entity's ID (from the model object)
                    entity.MinimumOrderDollarAmountBufferProductID = resolved.Result!.ID;
                    return;
                }
                // [Optional] Scenario 5: We have IDs but they don't match and the model has been deactivated, remove the entity from it's master
                entity.MinimumOrderDollarAmountBufferProductID = null;
                entity.MinimumOrderDollarAmountBufferProduct = null;
                return;
            }
            if (!entityIDIsNull && modelObjectIsActive)
            {
                // [Optional] Scenario 6: We have an entity id, but a new model, remove the id on the entity and assign the new model
                entity.MinimumOrderDollarAmountBufferProductID = null;
                entity.MinimumOrderDollarAmountBufferProduct = (Product)resolved.Result!.CreateProductEntity(timestamp, context.ContextProfileName);
                return;
            }
            if (entityIDIsNull && modelObjectIsActive)
            {
                // [Optional] Scenario 7: We don't have an entity id, and we have a new model, assign the new model
                entity.MinimumOrderDollarAmountBufferProduct = (Product)resolved.Result!.CreateProductEntity(timestamp, context.ContextProfileName);
                return;
            }
            if (!entityIDIsNull && modelIDIsNull && !modelObjectIsActive)
            {
                // [Optional] Scenario 8: We were removing or deactivating the object, clear it from the entity
                entity.MinimumOrderDollarAmountBufferProductID = null;
                entity.MinimumOrderDollarAmountBufferProduct = null;
                return;
            }
            // Note: We would do this if it wasn't just a base typable entity (like ReportType, which has extra values to adjust on the model)
            // if (!entityObjectIsNull && modelObjectIsActive && entityObjectAndModelObjectHaveSameID)
            // {
            //     // TODO: Determine 'Equals' object between the objects so we only update if different
            //     // [Optional] Scenario 9: We have data on both sides, update the object, assign the values using the Update action
            //     entity.MinimumOrderDollarAmountBufferProduct.UpdateProductFromModel(resolved.Result, updateTimestamp);
            //     return;
            // }
            // [Optional/Required] Scenario 10: Could not figure out what to do
            throw new InvalidOperationException(
                "Couldn't figure out how to relate the given MinimumOrderDollarAmountBufferProduct to the Store entity");
        }

        /// <summary>Relate Optional MinimumOrderQuantityAmountBufferProduct.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">            The entity that has a Optional MinimumOrderQuantityAmountBufferProduct.</param>
        /// <param name="model">             The model that has a Optional MinimumOrderQuantityAmountBufferProduct.</param>
        /// <param name="timestamp">         The timestamp Date/Time.</param>
        /// <param name="contextProfileName">Name of the context profile.</param>
        protected virtual async Task RelateOptionalMinimumOrderQuantityAmountBufferProductAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            await RelateOptionalMinimumOrderQuantityAmountBufferProductAsync(
                    entity,
                    model,
                    timestamp,
                    context)
                .ConfigureAwait(false);
        }

        /// <summary>Relate Optional MinimumOrderQuantityAmountBufferProduct.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">   The entity that has a Optional MinimumOrderQuantityAmountBufferProduct.</param>
        /// <param name="model">    The model that has a Optional MinimumOrderQuantityAmountBufferProduct.</param>
        /// <param name="timestamp">The timestamp Date/Time.</param>
        /// <param name="context">  The context.</param>
        // ReSharper disable once CyclomaticComplexity, CognitiveComplexity
        protected virtual async Task RelateOptionalMinimumOrderQuantityAmountBufferProductAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            IClarityEcommerceEntities context)
        {
            // Must have the core objects on both sides
            Contract.RequiresNotNull(entity);
            Contract.RequiresNotNull(model);
            // Look up the Object Model
            // Allowed to auto-generate if not found
            var resolved = await Workflows.Products.ResolveWithAutoGenerateOptionalAsync(
                    byID: model.MinimumOrderQuantityAmountBufferProductID, // By Other ID
                    byKey: model.MinimumOrderQuantityAmountBufferProductKey, // By Flattened Other Key
                    byName: model.MinimumOrderQuantityAmountBufferProductName, // By Flattened Other Name
                    model: model.MinimumOrderQuantityAmountBufferProduct, // The other property as a model
                    context: context)
                .ConfigureAwait(false);
            // Check for IDs and objects
            var entityIDIsNull = !Contract.CheckValidID(entity.MinimumOrderQuantityAmountBufferProductID);
            var modelIDIsNull = !Contract.CheckValidID(resolved.Result?.ID);
            var entityObjectIsNull = entity.MinimumOrderQuantityAmountBufferProduct == null;
            if (!resolved.ActionSucceeded && model.MinimumOrderQuantityAmountBufferProduct != null)
            {
                resolved.Result = model.MinimumOrderQuantityAmountBufferProduct;
            }
            var modelObjectIsNull = !resolved.ActionSucceeded;
            if (entityIDIsNull && modelIDIsNull && entityObjectIsNull && modelObjectIsNull)
            {
                // [Optional] Scenario 1: Nothing we can do with/to either end, so do nothing
                return;
            }
            var entityIDAndModelIDHaveSameID = !entityIDIsNull && !modelIDIsNull && entity.MinimumOrderQuantityAmountBufferProductID == resolved.Result!.ID;
            var entityObjectAndModelObjectHaveSameID = !entityObjectIsNull && !modelObjectIsNull && entity.MinimumOrderQuantityAmountBufferProductID == resolved.Result!.ID;
            if (entityIDAndModelIDHaveSameID || entityObjectAndModelObjectHaveSameID)
            {
                // [Optional/Required] Scenario 2: They match IDs, just update the entity from the model if it is present
                if (!entityObjectIsNull && !modelObjectIsNull)
                {
                    entity.MinimumOrderQuantityAmountBufferProduct!.UpdateProductFromModel(resolved.Result!, timestamp, timestamp);
                }
                return;
            }
            if (!modelIDIsNull)
            {
                // [Optional/Required] Scenario 3: We have IDs but they don't match, assign the model's ID to the entity's ID
                entity.MinimumOrderQuantityAmountBufferProductID = resolved.Result!.ID;
                if (!modelObjectIsNull)
                {
                    if (!entityObjectIsNull)
                    {
                        // [Optional/Required] Scenario 3a: We can't update the existing object because it's the wrong one
                    }
                    else
                    {
                        // [Optional/Required] Scenario 3b: We can't assign a new object in on this entity because it would duplicate the record
                    }
                }
                return;
            }
            var modelObjectIDIsNull = !modelObjectIsNull && !Contract.CheckValidID(resolved.Result!.ID);
            var modelObjectIsActive = !modelObjectIsNull && resolved.Result!.Active;
            if (!modelObjectIsNull && !modelObjectIDIsNull)
            {
                if (modelObjectIsActive)
                {
                    // [Optional] Scenario 4: We have IDs but they don't match, assign the model's ID to the entity's ID (from the model object)
                    entity.MinimumOrderQuantityAmountBufferProductID = resolved.Result!.ID;
                    return;
                }
                // [Optional] Scenario 5: We have IDs but they don't match and the model has been deactivated, remove the entity from it's master
                entity.MinimumOrderQuantityAmountBufferProductID = null;
                entity.MinimumOrderQuantityAmountBufferProduct = null;
                return;
            }
            if (!entityIDIsNull && modelObjectIsActive)
            {
                // [Optional] Scenario 6: We have an entity id, but a new model, remove the id on the entity and assign the new model
                entity.MinimumOrderQuantityAmountBufferProductID = null;
                entity.MinimumOrderQuantityAmountBufferProduct = (Product)resolved.Result!.CreateProductEntity(timestamp, context.ContextProfileName);
                return;
            }
            if (entityIDIsNull && modelObjectIsActive)
            {
                // [Optional] Scenario 7: We don't have an entity id, and we have a new model, assign the new model
                entity.MinimumOrderQuantityAmountBufferProduct = (Product)resolved.Result!.CreateProductEntity(timestamp, context.ContextProfileName);
                return;
            }
            if (!entityIDIsNull && modelIDIsNull && !modelObjectIsActive)
            {
                // [Optional] Scenario 8: We were removing or deactivating the object, clear it from the entity
                entity.MinimumOrderQuantityAmountBufferProductID = null;
                entity.MinimumOrderQuantityAmountBufferProduct = null;
                return;
            }
            // Note: We would do this if it wasn't just a base typable entity (like ReportType, which has extra values to adjust on the model)
            // if (!entityObjectIsNull && modelObjectIsActive && entityObjectAndModelObjectHaveSameID)
            // {
            //     // TODO: Determine 'Equals' object between the objects so we only update if different
            //     // [Optional] Scenario 9: We have data on both sides, update the object, assign the values using the Update action
            //     entity.MinimumOrderQuantityAmountBufferProduct.UpdateProductFromModel(resolved.Result, updateTimestamp);
            //     return;
            // }
            // [Optional/Required] Scenario 10: Could not figure out what to do
            throw new InvalidOperationException(
                "Couldn't figure out how to relate the given MinimumOrderQuantityAmountBufferProduct to the Store entity");
        }

        /// <summary>Relate Optional MinimumOrderDollarAmountBufferCategory.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">            The entity that has a Optional MinimumOrderDollarAmountBufferCategory.</param>
        /// <param name="model">             The model that has a Optional MinimumOrderDollarAmountBufferCategory.</param>
        /// <param name="timestamp">         The timestamp Date/Time.</param>
        /// <param name="contextProfileName">Name of the context profile.</param>
        protected virtual async Task RelateOptionalMinimumOrderDollarAmountBufferCategoryAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            await RelateOptionalMinimumOrderDollarAmountBufferCategoryAsync(
                    entity,
                    model,
                    timestamp,
                    context)
                .ConfigureAwait(false);
        }

        /// <summary>Relate Optional MinimumOrderDollarAmountBufferCategory.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">   The entity that has a Optional MinimumOrderDollarAmountBufferCategory.</param>
        /// <param name="model">    The model that has a Optional MinimumOrderDollarAmountBufferCategory.</param>
        /// <param name="timestamp">The timestamp Date/Time.</param>
        /// <param name="context">  The context.</param>
        // ReSharper disable once CyclomaticComplexity, CognitiveComplexity
        protected virtual async Task RelateOptionalMinimumOrderDollarAmountBufferCategoryAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            IClarityEcommerceEntities context)
        {
            // Must have the core objects on both sides
            Contract.RequiresNotNull(entity);
            Contract.RequiresNotNull(model);
            // Look up the Object Model
            // Allowed to auto-generate if not found
            var resolved = await Workflows.Categories.ResolveWithAutoGenerateOptionalAsync(
                    byID: model.MinimumOrderDollarAmountBufferCategoryID, // By Other ID
                    byKey: model.MinimumOrderDollarAmountBufferCategoryKey, // By Flattened Other Key
                    byName: model.MinimumOrderDollarAmountBufferCategoryName, // By Flattened Other Name
                    model: model.MinimumOrderDollarAmountBufferCategory, // The other property as a model
                    context: context)
                .ConfigureAwait(false);
            // Check for IDs and objects
            var entityIDIsNull = !Contract.CheckValidID(entity.MinimumOrderDollarAmountBufferCategoryID);
            var modelIDIsNull = !Contract.CheckValidID(resolved.Result?.ID);
            var entityObjectIsNull = entity.MinimumOrderDollarAmountBufferCategory == null;
            if (!resolved.ActionSucceeded && model.MinimumOrderDollarAmountBufferCategory != null)
            {
                resolved.Result = model.MinimumOrderDollarAmountBufferCategory;
            }
            var modelObjectIsNull = !resolved.ActionSucceeded;
            if (entityIDIsNull && modelIDIsNull && entityObjectIsNull && modelObjectIsNull)
            {
                // [Optional] Scenario 1: Nothing we can do with/to either end, so do nothing
                return;
            }
            var entityIDAndModelIDHaveSameID = !entityIDIsNull && !modelIDIsNull && entity.MinimumOrderDollarAmountBufferCategoryID == resolved.Result!.ID;
            var entityObjectAndModelObjectHaveSameID = !entityObjectIsNull && !modelObjectIsNull && entity.MinimumOrderDollarAmountBufferCategoryID == resolved.Result!.ID;
            if (entityIDAndModelIDHaveSameID || entityObjectAndModelObjectHaveSameID)
            {
                // [Optional/Required] Scenario 2: They match IDs, just update the entity from the model if it is present
                if (!entityObjectIsNull && !modelObjectIsNull)
                {
                    entity.MinimumOrderDollarAmountBufferCategory!.UpdateCategoryFromModel(resolved.Result!, timestamp, timestamp);
                }
                return;
            }
            if (!modelIDIsNull)
            {
                // [Optional/Required] Scenario 3: We have IDs but they don't match, assign the model's ID to the entity's ID
                entity.MinimumOrderDollarAmountBufferCategoryID = resolved.Result!.ID;
                if (!modelObjectIsNull)
                {
                    if (!entityObjectIsNull)
                    {
                        // [Optional/Required] Scenario 3a: We can't update the existing object because it's the wrong one
                    }
                    else
                    {
                        // [Optional/Required] Scenario 3b: We can't assign a new object in on this entity because it would duplicate the record
                    }
                }
                return;
            }
            var modelObjectIDIsNull = !modelObjectIsNull && !Contract.CheckValidID(resolved.Result!.ID);
            var modelObjectIsActive = !modelObjectIsNull && resolved.Result!.Active;
            if (!modelObjectIsNull && !modelObjectIDIsNull)
            {
                if (modelObjectIsActive)
                {
                    // [Optional] Scenario 4: We have IDs but they don't match, assign the model's ID to the entity's ID (from the model object)
                    entity.MinimumOrderDollarAmountBufferCategoryID = resolved.Result!.ID;
                    return;
                }
                // [Optional] Scenario 5: We have IDs but they don't match and the model has been deactivated, remove the entity from it's master
                entity.MinimumOrderDollarAmountBufferCategoryID = null;
                entity.MinimumOrderDollarAmountBufferCategory = null;
                return;
            }
            if (!entityIDIsNull && modelObjectIsActive)
            {
                // [Optional] Scenario 6: We have an entity id, but a new model, remove the id on the entity and assign the new model
                entity.MinimumOrderDollarAmountBufferCategoryID = null;
                entity.MinimumOrderDollarAmountBufferCategory = (Category)resolved.Result!.CreateCategoryEntity(timestamp, context.ContextProfileName);
                return;
            }
            if (entityIDIsNull && modelObjectIsActive)
            {
                // [Optional] Scenario 7: We don't have an entity id, and we have a new model, assign the new model
                entity.MinimumOrderDollarAmountBufferCategory = (Category)resolved.Result!.CreateCategoryEntity(timestamp, context.ContextProfileName);
                return;
            }
            if (!entityIDIsNull && modelIDIsNull && !modelObjectIsActive)
            {
                // [Optional] Scenario 8: We were removing or deactivating the object, clear it from the entity
                entity.MinimumOrderDollarAmountBufferCategoryID = null;
                entity.MinimumOrderDollarAmountBufferCategory = null;
                return;
            }
            // Note: We would do this if it wasn't just a base typable entity (like ReportType, which has extra values to adjust on the model)
            // if (!entityObjectIsNull && modelObjectIsActive && entityObjectAndModelObjectHaveSameID)
            // {
            //     // TODO: Determine 'Equals' object between the objects so we only update if different
            //     // [Optional] Scenario 9: We have data on both sides, update the object, assign the values using the Update action
            //     entity.MinimumOrderDollarAmountBufferCategory.UpdateCategoryFromModel(resolved.Result, updateTimestamp);
            //     return;
            // }
            // [Optional/Required] Scenario 10: Could not figure out what to do
            throw new InvalidOperationException(
                "Couldn't figure out how to relate the given MinimumOrderDollarAmountBufferCategory to the Store entity");
        }

        /// <summary>Relate Optional MinimumOrderQuantityAmountBufferCategory.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">            The entity that has a Optional MinimumOrderQuantityAmountBufferCategory.</param>
        /// <param name="model">             The model that has a Optional MinimumOrderQuantityAmountBufferCategory.</param>
        /// <param name="timestamp">         The timestamp Date/Time.</param>
        /// <param name="contextProfileName">Name of the context profile.</param>
        protected virtual async Task RelateOptionalMinimumOrderQuantityAmountBufferCategoryAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            await RelateOptionalMinimumOrderQuantityAmountBufferCategoryAsync(
                    entity,
                    model,
                    timestamp,
                    context)
                .ConfigureAwait(false);
        }

        /// <summary>Relate Optional MinimumOrderQuantityAmountBufferCategory.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">   The entity that has a Optional MinimumOrderQuantityAmountBufferCategory.</param>
        /// <param name="model">    The model that has a Optional MinimumOrderQuantityAmountBufferCategory.</param>
        /// <param name="timestamp">The timestamp Date/Time.</param>
        /// <param name="context">  The context.</param>
        // ReSharper disable once CyclomaticComplexity, CognitiveComplexity
        protected virtual async Task RelateOptionalMinimumOrderQuantityAmountBufferCategoryAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            IClarityEcommerceEntities context)
        {
            // Must have the core objects on both sides
            Contract.RequiresNotNull(entity);
            Contract.RequiresNotNull(model);
            // Look up the Object Model
            // Allowed to auto-generate if not found
            var resolved = await Workflows.Categories.ResolveWithAutoGenerateOptionalAsync(
                    byID: model.MinimumOrderQuantityAmountBufferCategoryID, // By Other ID
                    byKey: model.MinimumOrderQuantityAmountBufferCategoryKey, // By Flattened Other Key
                    byName: model.MinimumOrderQuantityAmountBufferCategoryName, // By Flattened Other Name
                    model: model.MinimumOrderQuantityAmountBufferCategory, // The other property as a model
                    context: context)
                .ConfigureAwait(false);
            // Check for IDs and objects
            var entityIDIsNull = !Contract.CheckValidID(entity.MinimumOrderQuantityAmountBufferCategoryID);
            var modelIDIsNull = !Contract.CheckValidID(resolved.Result?.ID);
            var entityObjectIsNull = entity.MinimumOrderQuantityAmountBufferCategory == null;
            if (!resolved.ActionSucceeded && model.MinimumOrderQuantityAmountBufferCategory != null)
            {
                resolved.Result = model.MinimumOrderQuantityAmountBufferCategory;
            }
            var modelObjectIsNull = !resolved.ActionSucceeded;
            if (entityIDIsNull && modelIDIsNull && entityObjectIsNull && modelObjectIsNull)
            {
                // [Optional] Scenario 1: Nothing we can do with/to either end, so do nothing
                return;
            }
            var entityIDAndModelIDHaveSameID = !entityIDIsNull && !modelIDIsNull && entity.MinimumOrderQuantityAmountBufferCategoryID == resolved.Result!.ID;
            var entityObjectAndModelObjectHaveSameID = !entityObjectIsNull && !modelObjectIsNull && entity.MinimumOrderQuantityAmountBufferCategoryID == resolved.Result!.ID;
            if (entityIDAndModelIDHaveSameID || entityObjectAndModelObjectHaveSameID)
            {
                // [Optional/Required] Scenario 2: They match IDs, just update the entity from the model if it is present
                if (!entityObjectIsNull && !modelObjectIsNull)
                {
                    entity.MinimumOrderQuantityAmountBufferCategory!.UpdateCategoryFromModel(resolved.Result!, timestamp, timestamp);
                }
                return;
            }
            if (!modelIDIsNull)
            {
                // [Optional/Required] Scenario 3: We have IDs but they don't match, assign the model's ID to the entity's ID
                entity.MinimumOrderQuantityAmountBufferCategoryID = resolved.Result!.ID;
                if (!modelObjectIsNull)
                {
                    if (!entityObjectIsNull)
                    {
                        // [Optional/Required] Scenario 3a: We can't update the existing object because it's the wrong one
                    }
                    else
                    {
                        // [Optional/Required] Scenario 3b: We can't assign a new object in on this entity because it would duplicate the record
                    }
                }
                return;
            }
            var modelObjectIDIsNull = !modelObjectIsNull && !Contract.CheckValidID(resolved.Result!.ID);
            var modelObjectIsActive = !modelObjectIsNull && resolved.Result!.Active;
            if (!modelObjectIsNull && !modelObjectIDIsNull)
            {
                if (modelObjectIsActive)
                {
                    // [Optional] Scenario 4: We have IDs but they don't match, assign the model's ID to the entity's ID (from the model object)
                    entity.MinimumOrderQuantityAmountBufferCategoryID = resolved.Result!.ID;
                    return;
                }
                // [Optional] Scenario 5: We have IDs but they don't match and the model has been deactivated, remove the entity from it's master
                entity.MinimumOrderQuantityAmountBufferCategoryID = null;
                entity.MinimumOrderQuantityAmountBufferCategory = null;
                return;
            }
            if (!entityIDIsNull && modelObjectIsActive)
            {
                // [Optional] Scenario 6: We have an entity id, but a new model, remove the id on the entity and assign the new model
                entity.MinimumOrderQuantityAmountBufferCategoryID = null;
                entity.MinimumOrderQuantityAmountBufferCategory = (Category)resolved.Result!.CreateCategoryEntity(timestamp, context.ContextProfileName);
                return;
            }
            if (entityIDIsNull && modelObjectIsActive)
            {
                // [Optional] Scenario 7: We don't have an entity id, and we have a new model, assign the new model
                entity.MinimumOrderQuantityAmountBufferCategory = (Category)resolved.Result!.CreateCategoryEntity(timestamp, context.ContextProfileName);
                return;
            }
            if (!entityIDIsNull && modelIDIsNull && !modelObjectIsActive)
            {
                // [Optional] Scenario 8: We were removing or deactivating the object, clear it from the entity
                entity.MinimumOrderQuantityAmountBufferCategoryID = null;
                entity.MinimumOrderQuantityAmountBufferCategory = null;
                return;
            }
            // Note: We would do this if it wasn't just a base typable entity (like ReportType, which has extra values to adjust on the model)
            // if (!entityObjectIsNull && modelObjectIsActive && entityObjectAndModelObjectHaveSameID)
            // {
            //     // TODO: Determine 'Equals' object between the objects so we only update if different
            //     // [Optional] Scenario 9: We have data on both sides, update the object, assign the values using the Update action
            //     entity.MinimumOrderQuantityAmountBufferCategory.UpdateCategoryFromModel(resolved.Result, updateTimestamp);
            //     return;
            // }
            // [Optional/Required] Scenario 10: Could not figure out what to do
            throw new InvalidOperationException(
                "Couldn't figure out how to relate the given MinimumOrderQuantityAmountBufferCategory to the Store entity");
        }

        /// <summary>Relate Optional MinimumForFreeShippingDollarAmountBufferProduct.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">            The entity that has a Optional MinimumForFreeShippingDollarAmountBufferProduct.</param>
        /// <param name="model">             The model that has a Optional MinimumForFreeShippingDollarAmountBufferProduct.</param>
        /// <param name="timestamp">         The timestamp Date/Time.</param>
        /// <param name="contextProfileName">Name of the context profile.</param>
        protected virtual async Task RelateOptionalMinimumForFreeShippingDollarAmountBufferProductAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            await RelateOptionalMinimumForFreeShippingDollarAmountBufferProductAsync(
                    entity,
                    model,
                    timestamp,
                    context)
                .ConfigureAwait(false);
        }

        /// <summary>Relate Optional MinimumForFreeShippingDollarAmountBufferProduct.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">   The entity that has a Optional MinimumForFreeShippingDollarAmountBufferProduct.</param>
        /// <param name="model">    The model that has a Optional MinimumForFreeShippingDollarAmountBufferProduct.</param>
        /// <param name="timestamp">The timestamp Date/Time.</param>
        /// <param name="context">  The context.</param>
        // ReSharper disable once CyclomaticComplexity, CognitiveComplexity
        protected virtual async Task RelateOptionalMinimumForFreeShippingDollarAmountBufferProductAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            IClarityEcommerceEntities context)
        {
            // Must have the core objects on both sides
            Contract.RequiresNotNull(entity);
            Contract.RequiresNotNull(model);
            // Look up the Object Model
            // Allowed to auto-generate if not found
            var resolved = await Workflows.Products.ResolveWithAutoGenerateOptionalAsync(
                    byID: model.MinimumForFreeShippingDollarAmountBufferProductID, // By Other ID
                    byKey: model.MinimumForFreeShippingDollarAmountBufferProductKey, // By Flattened Other Key
                    byName: model.MinimumForFreeShippingDollarAmountBufferProductName, // By Flattened Other Name
                    model: model.MinimumForFreeShippingDollarAmountBufferProduct, // The other property as a model
                    context: context)
                .ConfigureAwait(false);
            // Check for IDs and objects
            var entityIDIsNull = !Contract.CheckValidID(entity.MinimumForFreeShippingDollarAmountBufferProductID);
            var modelIDIsNull = !Contract.CheckValidID(resolved.Result?.ID);
            var entityObjectIsNull = entity.MinimumForFreeShippingDollarAmountBufferProduct == null;
            if (!resolved.ActionSucceeded && model.MinimumForFreeShippingDollarAmountBufferProduct != null)
            {
                resolved.Result = model.MinimumForFreeShippingDollarAmountBufferProduct;
            }
            var modelObjectIsNull = !resolved.ActionSucceeded;
            if (entityIDIsNull && modelIDIsNull && entityObjectIsNull && modelObjectIsNull)
            {
                // [Optional] Scenario 1: Nothing we can do with/to either end, so do nothing
                return;
            }
            var entityIDAndModelIDHaveSameID = !entityIDIsNull && !modelIDIsNull && entity.MinimumForFreeShippingDollarAmountBufferProductID == resolved.Result!.ID;
            var entityObjectAndModelObjectHaveSameID = !entityObjectIsNull && !modelObjectIsNull && entity.MinimumForFreeShippingDollarAmountBufferProductID == resolved.Result!.ID;
            if (entityIDAndModelIDHaveSameID || entityObjectAndModelObjectHaveSameID)
            {
                // [Optional/Required] Scenario 2: They match IDs, just update the entity from the model if it is present
                if (!entityObjectIsNull && !modelObjectIsNull)
                {
                    entity.MinimumForFreeShippingDollarAmountBufferProduct!.UpdateProductFromModel(resolved.Result!, timestamp, timestamp);
                }
                return;
            }
            if (!modelIDIsNull)
            {
                // [Optional/Required] Scenario 3: We have IDs but they don't match, assign the model's ID to the entity's ID
                entity.MinimumForFreeShippingDollarAmountBufferProductID = resolved.Result!.ID;
                if (!modelObjectIsNull)
                {
                    if (!entityObjectIsNull)
                    {
                        // [Optional/Required] Scenario 3a: We can't update the existing object because it's the wrong one
                    }
                    else
                    {
                        // [Optional/Required] Scenario 3b: We can't assign a new object in on this entity because it would duplicate the record
                    }
                }
                return;
            }
            var modelObjectIDIsNull = !modelObjectIsNull && !Contract.CheckValidID(resolved.Result!.ID);
            var modelObjectIsActive = !modelObjectIsNull && resolved.Result!.Active;
            if (!modelObjectIsNull && !modelObjectIDIsNull)
            {
                if (modelObjectIsActive)
                {
                    // [Optional] Scenario 4: We have IDs but they don't match, assign the model's ID to the entity's ID (from the model object)
                    entity.MinimumForFreeShippingDollarAmountBufferProductID = resolved.Result!.ID;
                    return;
                }
                // [Optional] Scenario 5: We have IDs but they don't match and the model has been deactivated, remove the entity from it's master
                entity.MinimumForFreeShippingDollarAmountBufferProductID = null;
                entity.MinimumForFreeShippingDollarAmountBufferProduct = null;
                return;
            }
            if (!entityIDIsNull && modelObjectIsActive)
            {
                // [Optional] Scenario 6: We have an entity id, but a new model, remove the id on the entity and assign the new model
                entity.MinimumForFreeShippingDollarAmountBufferProductID = null;
                entity.MinimumForFreeShippingDollarAmountBufferProduct = (Product)resolved.Result!.CreateProductEntity(timestamp, context.ContextProfileName);
                return;
            }
            if (entityIDIsNull && modelObjectIsActive)
            {
                // [Optional] Scenario 7: We don't have an entity id, and we have a new model, assign the new model
                entity.MinimumForFreeShippingDollarAmountBufferProduct = (Product)resolved.Result!.CreateProductEntity(timestamp, context.ContextProfileName);
                return;
            }
            if (!entityIDIsNull && modelIDIsNull && !modelObjectIsActive)
            {
                // [Optional] Scenario 8: We were removing or deactivating the object, clear it from the entity
                entity.MinimumForFreeShippingDollarAmountBufferProductID = null;
                entity.MinimumForFreeShippingDollarAmountBufferProduct = null;
                return;
            }
            // Note: We would do this if it wasn't just a base typable entity (like ReportType, which has extra values to adjust on the model)
            // if (!entityObjectIsNull && modelObjectIsActive && entityObjectAndModelObjectHaveSameID)
            // {
            //     // TODO: Determine 'Equals' object between the objects so we only update if different
            //     // [Optional] Scenario 9: We have data on both sides, update the object, assign the values using the Update action
            //     entity.MinimumForFreeShippingDollarAmountBufferProduct.UpdateProductFromModel(resolved.Result, updateTimestamp);
            //     return;
            // }
            // [Optional/Required] Scenario 10: Could not figure out what to do
            throw new InvalidOperationException(
                "Couldn't figure out how to relate the given MinimumForFreeShippingDollarAmountBufferProduct to the Store entity");
        }

        /// <summary>Relate Optional MinimumForFreeShippingQuantityAmountBufferProduct.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">            The entity that has a Optional MinimumForFreeShippingQuantityAmountBufferProduct.</param>
        /// <param name="model">             The model that has a Optional MinimumForFreeShippingQuantityAmountBufferProduct.</param>
        /// <param name="timestamp">         The timestamp Date/Time.</param>
        /// <param name="contextProfileName">Name of the context profile.</param>
        protected virtual async Task RelateOptionalMinimumForFreeShippingQuantityAmountBufferProductAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            await RelateOptionalMinimumForFreeShippingQuantityAmountBufferProductAsync(
                    entity,
                    model,
                    timestamp,
                    context)
                .ConfigureAwait(false);
        }

        /// <summary>Relate Optional MinimumForFreeShippingQuantityAmountBufferProduct.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">   The entity that has a Optional MinimumForFreeShippingQuantityAmountBufferProduct.</param>
        /// <param name="model">    The model that has a Optional MinimumForFreeShippingQuantityAmountBufferProduct.</param>
        /// <param name="timestamp">The timestamp Date/Time.</param>
        /// <param name="context">  The context.</param>
        // ReSharper disable once CyclomaticComplexity, CognitiveComplexity
        protected virtual async Task RelateOptionalMinimumForFreeShippingQuantityAmountBufferProductAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            IClarityEcommerceEntities context)
        {
            // Must have the core objects on both sides
            Contract.RequiresNotNull(entity);
            Contract.RequiresNotNull(model);
            // Look up the Object Model
            // Allowed to auto-generate if not found
            var resolved = await Workflows.Products.ResolveWithAutoGenerateOptionalAsync(
                    byID: model.MinimumForFreeShippingQuantityAmountBufferProductID, // By Other ID
                    byKey: model.MinimumForFreeShippingQuantityAmountBufferProductKey, // By Flattened Other Key
                    byName: model.MinimumForFreeShippingQuantityAmountBufferProductName, // By Flattened Other Name
                    model: model.MinimumForFreeShippingQuantityAmountBufferProduct, // The other property as a model
                    context: context)
                .ConfigureAwait(false);
            // Check for IDs and objects
            var entityIDIsNull = !Contract.CheckValidID(entity.MinimumForFreeShippingQuantityAmountBufferProductID);
            var modelIDIsNull = !Contract.CheckValidID(resolved.Result?.ID);
            var entityObjectIsNull = entity.MinimumForFreeShippingQuantityAmountBufferProduct == null;
            if (!resolved.ActionSucceeded && model.MinimumForFreeShippingQuantityAmountBufferProduct != null)
            {
                resolved.Result = model.MinimumForFreeShippingQuantityAmountBufferProduct;
            }
            var modelObjectIsNull = !resolved.ActionSucceeded;
            if (entityIDIsNull && modelIDIsNull && entityObjectIsNull && modelObjectIsNull)
            {
                // [Optional] Scenario 1: Nothing we can do with/to either end, so do nothing
                return;
            }
            var entityIDAndModelIDHaveSameID = !entityIDIsNull && !modelIDIsNull && entity.MinimumForFreeShippingQuantityAmountBufferProductID == resolved.Result!.ID;
            var entityObjectAndModelObjectHaveSameID = !entityObjectIsNull && !modelObjectIsNull && entity.MinimumForFreeShippingQuantityAmountBufferProductID == resolved.Result!.ID;
            if (entityIDAndModelIDHaveSameID || entityObjectAndModelObjectHaveSameID)
            {
                // [Optional/Required] Scenario 2: They match IDs, just update the entity from the model if it is present
                if (!entityObjectIsNull && !modelObjectIsNull)
                {
                    entity.MinimumForFreeShippingQuantityAmountBufferProduct!.UpdateProductFromModel(resolved.Result!, timestamp, timestamp);
                }
                return;
            }
            if (!modelIDIsNull)
            {
                // [Optional/Required] Scenario 3: We have IDs but they don't match, assign the model's ID to the entity's ID
                entity.MinimumForFreeShippingQuantityAmountBufferProductID = resolved.Result!.ID;
                if (!modelObjectIsNull)
                {
                    if (!entityObjectIsNull)
                    {
                        // [Optional/Required] Scenario 3a: We can't update the existing object because it's the wrong one
                    }
                    else
                    {
                        // [Optional/Required] Scenario 3b: We can't assign a new object in on this entity because it would duplicate the record
                    }
                }
                return;
            }
            var modelObjectIDIsNull = !modelObjectIsNull && !Contract.CheckValidID(resolved.Result!.ID);
            var modelObjectIsActive = !modelObjectIsNull && resolved.Result!.Active;
            if (!modelObjectIsNull && !modelObjectIDIsNull)
            {
                if (modelObjectIsActive)
                {
                    // [Optional] Scenario 4: We have IDs but they don't match, assign the model's ID to the entity's ID (from the model object)
                    entity.MinimumForFreeShippingQuantityAmountBufferProductID = resolved.Result!.ID;
                    return;
                }
                // [Optional] Scenario 5: We have IDs but they don't match and the model has been deactivated, remove the entity from it's master
                entity.MinimumForFreeShippingQuantityAmountBufferProductID = null;
                entity.MinimumForFreeShippingQuantityAmountBufferProduct = null;
                return;
            }
            if (!entityIDIsNull && modelObjectIsActive)
            {
                // [Optional] Scenario 6: We have an entity id, but a new model, remove the id on the entity and assign the new model
                entity.MinimumForFreeShippingQuantityAmountBufferProductID = null;
                entity.MinimumForFreeShippingQuantityAmountBufferProduct = (Product)resolved.Result!.CreateProductEntity(timestamp, context.ContextProfileName);
                return;
            }
            if (entityIDIsNull && modelObjectIsActive)
            {
                // [Optional] Scenario 7: We don't have an entity id, and we have a new model, assign the new model
                entity.MinimumForFreeShippingQuantityAmountBufferProduct = (Product)resolved.Result!.CreateProductEntity(timestamp, context.ContextProfileName);
                return;
            }
            if (!entityIDIsNull && modelIDIsNull && !modelObjectIsActive)
            {
                // [Optional] Scenario 8: We were removing or deactivating the object, clear it from the entity
                entity.MinimumForFreeShippingQuantityAmountBufferProductID = null;
                entity.MinimumForFreeShippingQuantityAmountBufferProduct = null;
                return;
            }
            // Note: We would do this if it wasn't just a base typable entity (like ReportType, which has extra values to adjust on the model)
            // if (!entityObjectIsNull && modelObjectIsActive && entityObjectAndModelObjectHaveSameID)
            // {
            //     // TODO: Determine 'Equals' object between the objects so we only update if different
            //     // [Optional] Scenario 9: We have data on both sides, update the object, assign the values using the Update action
            //     entity.MinimumForFreeShippingQuantityAmountBufferProduct.UpdateProductFromModel(resolved.Result, updateTimestamp);
            //     return;
            // }
            // [Optional/Required] Scenario 10: Could not figure out what to do
            throw new InvalidOperationException(
                "Couldn't figure out how to relate the given MinimumForFreeShippingQuantityAmountBufferProduct to the Store entity");
        }

        /// <summary>Relate Optional MinimumForFreeShippingDollarAmountBufferCategory.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">            The entity that has a Optional MinimumForFreeShippingDollarAmountBufferCategory.</param>
        /// <param name="model">             The model that has a Optional MinimumForFreeShippingDollarAmountBufferCategory.</param>
        /// <param name="timestamp">         The timestamp Date/Time.</param>
        /// <param name="contextProfileName">Name of the context profile.</param>
        protected virtual async Task RelateOptionalMinimumForFreeShippingDollarAmountBufferCategoryAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            await RelateOptionalMinimumForFreeShippingDollarAmountBufferCategoryAsync(
                    entity,
                    model,
                    timestamp,
                    context)
                .ConfigureAwait(false);
        }

        /// <summary>Relate Optional MinimumForFreeShippingDollarAmountBufferCategory.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">   The entity that has a Optional MinimumForFreeShippingDollarAmountBufferCategory.</param>
        /// <param name="model">    The model that has a Optional MinimumForFreeShippingDollarAmountBufferCategory.</param>
        /// <param name="timestamp">The timestamp Date/Time.</param>
        /// <param name="context">  The context.</param>
        // ReSharper disable once CyclomaticComplexity, CognitiveComplexity
        protected virtual async Task RelateOptionalMinimumForFreeShippingDollarAmountBufferCategoryAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            IClarityEcommerceEntities context)
        {
            // Must have the core objects on both sides
            Contract.RequiresNotNull(entity);
            Contract.RequiresNotNull(model);
            // Look up the Object Model
            // Allowed to auto-generate if not found
            var resolved = await Workflows.Categories.ResolveWithAutoGenerateOptionalAsync(
                    byID: model.MinimumForFreeShippingDollarAmountBufferCategoryID, // By Other ID
                    byKey: model.MinimumForFreeShippingDollarAmountBufferCategoryKey, // By Flattened Other Key
                    byName: model.MinimumForFreeShippingDollarAmountBufferCategoryName, // By Flattened Other Name
                    model: model.MinimumForFreeShippingDollarAmountBufferCategory, // The other property as a model
                    context: context)
                .ConfigureAwait(false);
            // Check for IDs and objects
            var entityIDIsNull = !Contract.CheckValidID(entity.MinimumForFreeShippingDollarAmountBufferCategoryID);
            var modelIDIsNull = !Contract.CheckValidID(resolved.Result?.ID);
            var entityObjectIsNull = entity.MinimumForFreeShippingDollarAmountBufferCategory == null;
            if (!resolved.ActionSucceeded && model.MinimumForFreeShippingDollarAmountBufferCategory != null)
            {
                resolved.Result = model.MinimumForFreeShippingDollarAmountBufferCategory;
            }
            var modelObjectIsNull = !resolved.ActionSucceeded;
            if (entityIDIsNull && modelIDIsNull && entityObjectIsNull && modelObjectIsNull)
            {
                // [Optional] Scenario 1: Nothing we can do with/to either end, so do nothing
                return;
            }
            var entityIDAndModelIDHaveSameID = !entityIDIsNull && !modelIDIsNull && entity.MinimumForFreeShippingDollarAmountBufferCategoryID == resolved.Result!.ID;
            var entityObjectAndModelObjectHaveSameID = !entityObjectIsNull && !modelObjectIsNull && entity.MinimumForFreeShippingDollarAmountBufferCategoryID == resolved.Result!.ID;
            if (entityIDAndModelIDHaveSameID || entityObjectAndModelObjectHaveSameID)
            {
                // [Optional/Required] Scenario 2: They match IDs, just update the entity from the model if it is present
                if (!entityObjectIsNull && !modelObjectIsNull)
                {
                    entity.MinimumForFreeShippingDollarAmountBufferCategory!.UpdateCategoryFromModel(resolved.Result!, timestamp, timestamp);
                }
                return;
            }
            if (!modelIDIsNull)
            {
                // [Optional/Required] Scenario 3: We have IDs but they don't match, assign the model's ID to the entity's ID
                entity.MinimumForFreeShippingDollarAmountBufferCategoryID = resolved.Result!.ID;
                if (!modelObjectIsNull)
                {
                    if (!entityObjectIsNull)
                    {
                        // [Optional/Required] Scenario 3a: We can't update the existing object because it's the wrong one
                    }
                    else
                    {
                        // [Optional/Required] Scenario 3b: We can't assign a new object in on this entity because it would duplicate the record
                    }
                }
                return;
            }
            var modelObjectIDIsNull = !modelObjectIsNull && !Contract.CheckValidID(resolved.Result!.ID);
            var modelObjectIsActive = !modelObjectIsNull && resolved.Result!.Active;
            if (!modelObjectIsNull && !modelObjectIDIsNull)
            {
                if (modelObjectIsActive)
                {
                    // [Optional] Scenario 4: We have IDs but they don't match, assign the model's ID to the entity's ID (from the model object)
                    entity.MinimumForFreeShippingDollarAmountBufferCategoryID = resolved.Result!.ID;
                    return;
                }
                // [Optional] Scenario 5: We have IDs but they don't match and the model has been deactivated, remove the entity from it's master
                entity.MinimumForFreeShippingDollarAmountBufferCategoryID = null;
                entity.MinimumForFreeShippingDollarAmountBufferCategory = null;
                return;
            }
            if (!entityIDIsNull && modelObjectIsActive)
            {
                // [Optional] Scenario 6: We have an entity id, but a new model, remove the id on the entity and assign the new model
                entity.MinimumForFreeShippingDollarAmountBufferCategoryID = null;
                entity.MinimumForFreeShippingDollarAmountBufferCategory = (Category)resolved.Result!.CreateCategoryEntity(timestamp, context.ContextProfileName);
                return;
            }
            if (entityIDIsNull && modelObjectIsActive)
            {
                // [Optional] Scenario 7: We don't have an entity id, and we have a new model, assign the new model
                entity.MinimumForFreeShippingDollarAmountBufferCategory = (Category)resolved.Result!.CreateCategoryEntity(timestamp, context.ContextProfileName);
                return;
            }
            if (!entityIDIsNull && modelIDIsNull && !modelObjectIsActive)
            {
                // [Optional] Scenario 8: We were removing or deactivating the object, clear it from the entity
                entity.MinimumForFreeShippingDollarAmountBufferCategoryID = null;
                entity.MinimumForFreeShippingDollarAmountBufferCategory = null;
                return;
            }
            // Note: We would do this if it wasn't just a base typable entity (like ReportType, which has extra values to adjust on the model)
            // if (!entityObjectIsNull && modelObjectIsActive && entityObjectAndModelObjectHaveSameID)
            // {
            //     // TODO: Determine 'Equals' object between the objects so we only update if different
            //     // [Optional] Scenario 9: We have data on both sides, update the object, assign the values using the Update action
            //     entity.MinimumForFreeShippingDollarAmountBufferCategory.UpdateCategoryFromModel(resolved.Result, updateTimestamp);
            //     return;
            // }
            // [Optional/Required] Scenario 10: Could not figure out what to do
            throw new InvalidOperationException(
                "Couldn't figure out how to relate the given MinimumForFreeShippingDollarAmountBufferCategory to the Store entity");
        }

        /// <summary>Relate Optional MinimumForFreeShippingQuantityAmountBufferCategory.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">            The entity that has a Optional MinimumForFreeShippingQuantityAmountBufferCategory.</param>
        /// <param name="model">             The model that has a Optional MinimumForFreeShippingQuantityAmountBufferCategory.</param>
        /// <param name="timestamp">         The timestamp Date/Time.</param>
        /// <param name="contextProfileName">Name of the context profile.</param>
        protected virtual async Task RelateOptionalMinimumForFreeShippingQuantityAmountBufferCategoryAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            await RelateOptionalMinimumForFreeShippingQuantityAmountBufferCategoryAsync(
                    entity,
                    model,
                    timestamp,
                    context)
                .ConfigureAwait(false);
        }

        /// <summary>Relate Optional MinimumForFreeShippingQuantityAmountBufferCategory.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">   The entity that has a Optional MinimumForFreeShippingQuantityAmountBufferCategory.</param>
        /// <param name="model">    The model that has a Optional MinimumForFreeShippingQuantityAmountBufferCategory.</param>
        /// <param name="timestamp">The timestamp Date/Time.</param>
        /// <param name="context">  The context.</param>
        // ReSharper disable once CyclomaticComplexity, CognitiveComplexity
        protected virtual async Task RelateOptionalMinimumForFreeShippingQuantityAmountBufferCategoryAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            IClarityEcommerceEntities context)
        {
            // Must have the core objects on both sides
            Contract.RequiresNotNull(entity);
            Contract.RequiresNotNull(model);
            // Look up the Object Model
            // Allowed to auto-generate if not found
            var resolved = await Workflows.Categories.ResolveWithAutoGenerateOptionalAsync(
                    byID: model.MinimumForFreeShippingQuantityAmountBufferCategoryID, // By Other ID
                    byKey: model.MinimumForFreeShippingQuantityAmountBufferCategoryKey, // By Flattened Other Key
                    byName: model.MinimumForFreeShippingQuantityAmountBufferCategoryName, // By Flattened Other Name
                    model: model.MinimumForFreeShippingQuantityAmountBufferCategory, // The other property as a model
                    context: context)
                .ConfigureAwait(false);
            // Check for IDs and objects
            var entityIDIsNull = !Contract.CheckValidID(entity.MinimumForFreeShippingQuantityAmountBufferCategoryID);
            var modelIDIsNull = !Contract.CheckValidID(resolved.Result?.ID);
            var entityObjectIsNull = entity.MinimumForFreeShippingQuantityAmountBufferCategory == null;
            if (!resolved.ActionSucceeded && model.MinimumForFreeShippingQuantityAmountBufferCategory != null)
            {
                resolved.Result = model.MinimumForFreeShippingQuantityAmountBufferCategory;
            }
            var modelObjectIsNull = !resolved.ActionSucceeded;
            if (entityIDIsNull && modelIDIsNull && entityObjectIsNull && modelObjectIsNull)
            {
                // [Optional] Scenario 1: Nothing we can do with/to either end, so do nothing
                return;
            }
            var entityIDAndModelIDHaveSameID = !entityIDIsNull && !modelIDIsNull && entity.MinimumForFreeShippingQuantityAmountBufferCategoryID == resolved.Result!.ID;
            var entityObjectAndModelObjectHaveSameID = !entityObjectIsNull && !modelObjectIsNull && entity.MinimumForFreeShippingQuantityAmountBufferCategoryID == resolved.Result!.ID;
            if (entityIDAndModelIDHaveSameID || entityObjectAndModelObjectHaveSameID)
            {
                // [Optional/Required] Scenario 2: They match IDs, just update the entity from the model if it is present
                if (!entityObjectIsNull && !modelObjectIsNull)
                {
                    entity.MinimumForFreeShippingQuantityAmountBufferCategory!.UpdateCategoryFromModel(resolved.Result!, timestamp, timestamp);
                }
                return;
            }
            if (!modelIDIsNull)
            {
                // [Optional/Required] Scenario 3: We have IDs but they don't match, assign the model's ID to the entity's ID
                entity.MinimumForFreeShippingQuantityAmountBufferCategoryID = resolved.Result!.ID;
                if (!modelObjectIsNull)
                {
                    if (!entityObjectIsNull)
                    {
                        // [Optional/Required] Scenario 3a: We can't update the existing object because it's the wrong one
                    }
                    else
                    {
                        // [Optional/Required] Scenario 3b: We can't assign a new object in on this entity because it would duplicate the record
                    }
                }
                return;
            }
            var modelObjectIDIsNull = !modelObjectIsNull && !Contract.CheckValidID(resolved.Result!.ID);
            var modelObjectIsActive = !modelObjectIsNull && resolved.Result!.Active;
            if (!modelObjectIsNull && !modelObjectIDIsNull)
            {
                if (modelObjectIsActive)
                {
                    // [Optional] Scenario 4: We have IDs but they don't match, assign the model's ID to the entity's ID (from the model object)
                    entity.MinimumForFreeShippingQuantityAmountBufferCategoryID = resolved.Result!.ID;
                    return;
                }
                // [Optional] Scenario 5: We have IDs but they don't match and the model has been deactivated, remove the entity from it's master
                entity.MinimumForFreeShippingQuantityAmountBufferCategoryID = null;
                entity.MinimumForFreeShippingQuantityAmountBufferCategory = null;
                return;
            }
            if (!entityIDIsNull && modelObjectIsActive)
            {
                // [Optional] Scenario 6: We have an entity id, but a new model, remove the id on the entity and assign the new model
                entity.MinimumForFreeShippingQuantityAmountBufferCategoryID = null;
                entity.MinimumForFreeShippingQuantityAmountBufferCategory = (Category)resolved.Result!.CreateCategoryEntity(timestamp, context.ContextProfileName);
                return;
            }
            if (entityIDIsNull && modelObjectIsActive)
            {
                // [Optional] Scenario 7: We don't have an entity id, and we have a new model, assign the new model
                entity.MinimumForFreeShippingQuantityAmountBufferCategory = (Category)resolved.Result!.CreateCategoryEntity(timestamp, context.ContextProfileName);
                return;
            }
            if (!entityIDIsNull && modelIDIsNull && !modelObjectIsActive)
            {
                // [Optional] Scenario 8: We were removing or deactivating the object, clear it from the entity
                entity.MinimumForFreeShippingQuantityAmountBufferCategoryID = null;
                entity.MinimumForFreeShippingQuantityAmountBufferCategory = null;
                return;
            }
            // Note: We would do this if it wasn't just a base typable entity (like ReportType, which has extra values to adjust on the model)
            // if (!entityObjectIsNull && modelObjectIsActive && entityObjectAndModelObjectHaveSameID)
            // {
            //     // TODO: Determine 'Equals' object between the objects so we only update if different
            //     // [Optional] Scenario 9: We have data on both sides, update the object, assign the values using the Update action
            //     entity.MinimumForFreeShippingQuantityAmountBufferCategory.UpdateCategoryFromModel(resolved.Result, updateTimestamp);
            //     return;
            // }
            // [Optional/Required] Scenario 10: Could not figure out what to do
            throw new InvalidOperationException(
                "Couldn't figure out how to relate the given MinimumForFreeShippingQuantityAmountBufferCategory to the Store entity");
        }

        /// <summary>Relate Optional Language.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">            The entity that has a Optional Language.</param>
        /// <param name="model">             The model that has a Optional Language.</param>
        /// <param name="timestamp">         The timestamp Date/Time.</param>
        /// <param name="contextProfileName">Name of the context profile.</param>
        protected virtual async Task RelateOptionalLanguageAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            await RelateOptionalLanguageAsync(
                    entity,
                    model,
                    timestamp,
                    context)
                .ConfigureAwait(false);
        }

        /// <summary>Relate Optional Language.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">   The entity that has a Optional Language.</param>
        /// <param name="model">    The model that has a Optional Language.</param>
        /// <param name="timestamp">The timestamp Date/Time.</param>
        /// <param name="context">  The context.</param>
        // ReSharper disable once CyclomaticComplexity, CognitiveComplexity
        protected virtual async Task RelateOptionalLanguageAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            IClarityEcommerceEntities context)
        {
            // Must have the core objects on both sides
            Contract.RequiresNotNull(entity);
            Contract.RequiresNotNull(model);
            // Look up the Object Model
            // May resolve but not allowed to auto-generate
            var resolved = await Workflows.Languages.ResolveAsync(
                    byID: model.LanguageID, // By Other ID
                    byKey: model.LanguageKey, // By Flattened Other Key
                    model: model.Language, // Manual name if not UserProductType and not Discount or Discount and not Master
                    context: context,
                    isInner: true)
                .ConfigureAwait(false);
            // Check for IDs and objects
            var entityIDIsNull = !Contract.CheckValidID(entity.LanguageID);
            var modelIDIsNull = !Contract.CheckValidID(resolved.Result?.ID);
            var entityObjectIsNull = entity.Language == null;
            if (!resolved.ActionSucceeded && model.Language != null)
            {
                resolved.Result = model.Language;
            }
            var modelObjectIsNull = !resolved.ActionSucceeded;
            if (entityIDIsNull && modelIDIsNull && entityObjectIsNull && modelObjectIsNull)
            {
                // [Optional] Scenario 1: Nothing we can do with/to either end, so do nothing
                return;
            }
            var entityIDAndModelIDHaveSameID = !entityIDIsNull && !modelIDIsNull && entity.LanguageID == resolved.Result!.ID;
            var entityObjectAndModelObjectHaveSameID = !entityObjectIsNull && !modelObjectIsNull && entity.LanguageID == resolved.Result!.ID;
            if (entityIDAndModelIDHaveSameID || entityObjectAndModelObjectHaveSameID)
            {
                // [Optional/Required] Scenario 2: They match IDs, just update the entity from the model if it is present
                if (!entityObjectIsNull && !modelObjectIsNull)
                {
                    entity.Language!.UpdateLanguageFromModel(resolved.Result!, timestamp, timestamp);
                }
                return;
            }
            if (!modelIDIsNull)
            {
                // [Optional/Required] Scenario 3: We have IDs but they don't match, assign the model's ID to the entity's ID
                entity.LanguageID = resolved.Result!.ID;
                if (!modelObjectIsNull)
                {
                    if (!entityObjectIsNull)
                    {
                        // [Optional/Required] Scenario 3a: We can't update the existing object because it's the wrong one
                    }
                    else
                    {
                        // [Optional/Required] Scenario 3b: We can't assign a new object in on this entity because it would duplicate the record
                    }
                }
                return;
            }
            var modelObjectIDIsNull = !modelObjectIsNull && !Contract.CheckValidID(resolved.Result!.ID);
            var modelObjectIsActive = !modelObjectIsNull && resolved.Result!.Active;
            if (!modelObjectIsNull && !modelObjectIDIsNull)
            {
                if (modelObjectIsActive)
                {
                    // [Optional] Scenario 4: We have IDs but they don't match, assign the model's ID to the entity's ID (from the model object)
                    entity.LanguageID = resolved.Result!.ID;
                    return;
                }
                // [Optional] Scenario 5: We have IDs but they don't match and the model has been deactivated, remove the entity from it's master
                entity.LanguageID = null;
                entity.Language = null;
                return;
            }
            if (!entityIDIsNull && modelObjectIsActive)
            {
                // [Optional] Scenario 6: We have an entity id, but a new model, however we're not allowed to create, so throw as we can't handle this situation
                throw new InvalidOperationException("Cannot create a new record of type 'Language' in this manner.");
            }
            if (entityIDIsNull && modelObjectIsActive)
            {
                // [Optional] Scenario 7: We don't have an entity id, and we have a new model, however we're not allowed to create, so throw as we can't handle this situation
                throw new InvalidOperationException("Cannot create a new record of type 'Language' in this manner.");
            }
            if (!entityIDIsNull && modelIDIsNull && !modelObjectIsActive)
            {
                // [Optional] Scenario 8: We were removing or deactivating the object, clear it from the entity
                entity.LanguageID = null;
                entity.Language = null;
                return;
            }
            // Note: We would do this if it wasn't just a base typable entity (like ReportType, which has extra values to adjust on the model)
            // if (!entityObjectIsNull && modelObjectIsActive && entityObjectAndModelObjectHaveSameID)
            // {
            //     // TODO: Determine 'Equals' object between the objects so we only update if different
            //     // [Optional] Scenario 9: We have data on both sides, update the object, assign the values using the Update action
            //     entity.Language.UpdateLanguageFromModel(resolved.Result, updateTimestamp);
            //     return;
            // }
            // [Optional/Required] Scenario 10: Could not figure out what to do
            throw new InvalidOperationException(
                "Couldn't figure out how to relate the given Language to the Store entity");
        }

        /// <inheritdoc/>
        protected override async Task RunDefaultRelateWorkflowsAsync(
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            await RunDefaultRelateWorkflowsAsync(entity, model, timestamp, context).ConfigureAwait(false);
        }

        /// <inheritdoc/>
        // ReSharper disable AsyncConverter.AsyncAwaitMayBeElidedHighlighting, RedundantAwait
#pragma warning disable 1998
        protected override async Task RunDefaultRelateWorkflowsAsync(
#pragma warning restore 1998
            IStore entity,
            IStoreModel model,
            DateTime timestamp,
            IClarityEcommerceEntities context)
        {
            // NOTE: Can't use Task.WhenAll as the context isn't thread safe and will throw an exception is more than
            // one thing is running at the same time on the same context.
            await RelateRequiredTypeAsync(entity, model, timestamp, context).ConfigureAwait(false);
            await RelateOptionalContactAsync(entity, model, timestamp, context).ConfigureAwait(false);
            await RelateOptionalMinimumOrderDollarAmountBufferProductAsync(entity, model, timestamp, context).ConfigureAwait(false);
            await RelateOptionalMinimumOrderQuantityAmountBufferProductAsync(entity, model, timestamp, context).ConfigureAwait(false);
            await RelateOptionalMinimumOrderDollarAmountBufferCategoryAsync(entity, model, timestamp, context).ConfigureAwait(false);
            await RelateOptionalMinimumOrderQuantityAmountBufferCategoryAsync(entity, model, timestamp, context).ConfigureAwait(false);
            await RelateOptionalMinimumForFreeShippingDollarAmountBufferProductAsync(entity, model, timestamp, context).ConfigureAwait(false);
            await RelateOptionalMinimumForFreeShippingQuantityAmountBufferProductAsync(entity, model, timestamp, context).ConfigureAwait(false);
            await RelateOptionalMinimumForFreeShippingDollarAmountBufferCategoryAsync(entity, model, timestamp, context).ConfigureAwait(false);
            await RelateOptionalMinimumForFreeShippingQuantityAmountBufferCategoryAsync(entity, model, timestamp, context).ConfigureAwait(false);
            await RelateOptionalLanguageAsync(entity, model, timestamp, context).ConfigureAwait(false);
        }
        // ReSharper restore AsyncConverter.AsyncAwaitMayBeElidedHighlighting, RedundantAwait
        #endregion // Relate Workflows
    }
}
