<#@ assembly name="System"
#><#@ import namespace="System"
#><#@ import namespace="System.Collections"
#><#@ import namespace="System.Collections.Generic"
#><#@ import namespace="System.ComponentModel.DataAnnotations.Schema"
#><#@ import namespace="System.Diagnostics"
#><#@ import namespace="System.IO"
#><#@ import namespace="System.Linq"
#><#@ import namespace="System.Reflection"
#><#@ import namespace="CodeGenerator"
#><#@ import namespace="Clarity.Ecommerce.Interfaces.DataModel"
#><#@ import namespace="Clarity.Ecommerce.DataModel"
#><#+
void GenerateWorkflowsFile(string schema, Type theType, TypeDeterminer td)
{
    schema = schema.Replace("System", "Structure");
    var name = theType.Name;
    var modelName = HelpFunctions.SwapToModelType(name);
    var addedRelateFunctions = new List<string>();
    var extraTypes1  = modelName == "SalesItemBase" ? "<IApplied" + name + "DiscountModel>" : "";
    var extraTypes1b = modelName == "SalesItemBase" ? "{IApplied" + name + "DiscountModel}" : "";
    var extraTypes2  = modelName == "SalesItemBase" ? "<IApplied" + name + "DiscountModel, Applied" + name + "DiscountModel>" : "";
    var extraTypes2b = modelName == "SalesItemBase" ? "{IApplied" + name + "DiscountModel, Applied" + name + "DiscountModel}" : "";
#>// <autogenerated>
// <copyright file="<#= name #>Workflow.generated.cs" company="clarity-ventures.com">
// Copyright (c) 2016-<#= DateTime.Today.Year #> clarity-ventures.com. All rights reserved.
// </copyright>
// <summary>Implements the Workflow generated to provide base setups</summary>
// <remarks>This file was auto-generated by Workflows.tt, changes to this
// file will be overwritten automatically when the T4 template is run again</remarks>
// </autogenerated>
#nullable enable
// ReSharper disable ConvertToUsingDeclaration, InvertIf, ReturnValueOfPureMethodIsNotUsed, UnusedMember.Local
#pragma warning disable CS0618,CS1711,CS1572,CS1580,CS1581,CS1584
namespace Clarity.Ecommerce.Workflow
{
    using System;
    using System.Collections.Generic;
    using System.Data.Entity;
    using System.Linq;
    using System.Threading.Tasks;
    using DataModel;
    using Interfaces.DataModel;
    using Interfaces.Models;
    using Interfaces.Workflow;
    using Mapper;
    using Utilities;

    /// <summary>A workflow for <#= name #> entities.</summary>
    /// <seealso cref="<#= td.IsISalesCollectionBase ? "SalesCollection" : ""
        #><#= td.IsIStatusableBase ? "Statusable" : ""
        #><#= td.IsIStateableBase ? "Stateable" : "" #><#= td.IsITypableBase ? "Typable" : ""
        #><#= !td.IsIStatusableBase && !td.IsIStateableBase && !td.IsITypableBase && td.IsINameableBase ? "Nameable" : ""
        #>WorkflowBase{I<#= modelName #>Model, I<#= modelName #>SearchModel, I<#= name #>, <#= name #><#=
            td.IsISalesCollectionBase ? ", " + name + "Status, " + name + "Type, I" + HelpFunctions.SwapToModelType(td.RelatedTypeType.Name)
            + "Model, I" + name + "Item, " + name + "Item, Applied" + name + "Discount, " + name + "State, " + name + "File, I"
            + name + "FileModel, " + name + "Contact, I" + name + "ContactModel, " + name + "Event, I" + name + "EventModel, "
            + name + "EventType, Applied" + name + "ItemDiscount, " + name + "ItemTarget, IApplied" + name + "DiscountModel, IApplied"
            + name + "ItemDiscountModel" : "" #>}"/>
    /// <seealso cref="I<#= name #>Workflow"/>
<#+          if (td.IsDeprecated) { #>
    /// <obsolete><#= td.DeprecatedMessage #></obsolete>
    [Obsolete("<#= td.DeprecatedMessage #>", false)]
<#+          } #>
    public partial class <#= name #>Workflow
<#+          if (td.IsISalesCollectionBase) { #>
        : SalesCollectionWorkflowBase<I<#= modelName #>Model,
            I<#= modelName #>SearchModel,
            I<#= name #>,
            <#= name #>,
            <#= name #>Status,
            <#= name #>Type,
            I<#= HelpFunctions.SwapToModelType(td.RelatedTypeType.Name) #>Model,
            I<#= name #>Item,
            <#= name #>Item,
            Applied<#= name #>Discount,
            <#= name #>State,
            <#= name #>File,
            I<#= name #>FileModel,
            <#= name #>Contact,
            I<#= name #>ContactModel,
            <#= name #>Event,
            I<#= name #>EventModel,
            <#= name #>EventType,
            Applied<#= name #>ItemDiscount,
            <#= name #>ItemTarget,
            IApplied<#= name #>DiscountModel,
            IApplied<#= name #>ItemDiscountModel>
<#+          } else { #>
        : <#= td.IsIStatusableBase ? "Statusable" : "" #><#= td.IsIStateableBase ? "Stateable" : ""
                #><#= td.IsITypableBase ? "Typable" : ""
                #><#= !td.IsIStatusableBase && !td.IsIStateableBase && !td.IsITypableBase && td.IsINameableBase ? "Nameable" : ""
                #>WorkflowBase<I<#= modelName #>Model<#= extraTypes1 #>, I<#= modelName #>SearchModel, I<#= name #>, <#= name #>>
<#+          } #>
            , I<#= name #>Workflow
    {
        #region Mappers
        /// <inheritdoc/>
        protected override Func<<#= name #>?, string?, I<#= modelName #>Model<#= extraTypes1 #>?> MapFromConcreteFull
            => ModelMapperFor<#= name #>.Map<#= name #>ModelFromEntityFull;

        /// <inheritdoc/>
        protected override Func<IQueryable<<#= name #>>, string?, IEnumerable<I<#= modelName #>Model<#= extraTypes1 #>>> SelectLiteAndMapToModel
            => ModelMapperFor<#= name #>.SelectLite<#= name #>AndMapTo<#= modelName #>Model;

        /// <inheritdoc/>
        protected override Func<IQueryable<<#= name #>>, string?, IEnumerable<I<#= modelName #>Model<#= extraTypes1 #>>> SelectListAndMapToModel
            => ModelMapperFor<#= name #>.SelectList<#= name #>AndMapTo<#= modelName #>Model;

        /// <inheritdoc/>
        protected override Func<IQueryable<<#= name #>>, string?, I<#= modelName #>Model<#= extraTypes1 #>?> SelectFirstFullAndMapToModel
            => ModelMapperFor<#= name #>.SelectFirstFull<#= name #>AndMapTo<#= modelName #>Model;

        /// <inheritdoc/>
        protected override Func<I<#= name #>, I<#= modelName #>Model<#= extraTypes1 #>, DateTime, DateTime?, I<#= name #>> UpdateEntityFromModel
            => ModelMapperFor<#= name #>.Update<#= name #>FromModel;
        #endregion
<#+          if (td.IsIHaveSeoBase) { #>

        /// <inheritdoc/>
        public virtual async Task<DateTime?> GetLastModifiedForBySeoUrlResultAsync(string seoUrl, string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            return await GetLastModifiedForBySeoUrlResultAsync(seoUrl, context).ConfigureAwait(false);
        }

        /// <inheritdoc/>
        public virtual async Task<DateTime?> GetLastModifiedForBySeoUrlResultAsync(string seoUrl, IClarityEcommerceEntities context)
        {
            return await context.Set<<#= name #>>()
                .AsNoTracking()
                .FilterBySeoUrl(Contract.RequiresValidKey(seoUrl), true, false)
                .Select(x => x.UpdatedDate ?? x.CreatedDate)
                .SingleOrDefaultAsync()
                .ConfigureAwait(false);
        }

        /// <inheritdoc/>
        public virtual async Task<I<#= modelName #>Model<#= extraTypes1 #>?> GetBySeoUrlAsync(
            string seoUrl,
            string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            return await GetBySeoUrlAsync(seoUrl, context).ConfigureAwait(false);
        }

        /// <inheritdoc/>
        public virtual Task<I<#= modelName #>Model<#= extraTypes1 #>?> GetBySeoUrlAsync(
            string seoUrl,
            IClarityEcommerceEntities context)
        {
            return Task.FromResult(
                SelectFirstFullAndMapToModel(
                    context.Set<<#= name #>>()
                        .AsNoTracking()
                        .FilterBySeoUrl(Contract.RequiresValidKey(seoUrl), true, false),
                    context.ContextProfileName));
        }

        /// <inheritdoc/>
        public virtual async Task<int?> CheckExistsBySeoUrlAsync(string seoUrl, string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            return await CheckExistsBySeoUrlAsync(seoUrl, context).ConfigureAwait(false);
        }

        /// <inheritdoc/>
        public virtual Task<int?> CheckExistsBySeoUrlAsync(string seoUrl, IClarityEcommerceEntities context)
        {
            return context.Set<<#= name #>>()
                .FilterByActive(true)
                .FilterBySeoUrl(Contract.RequiresValidKey(seoUrl), true, false)
                .Select(x => (int?)x.ID)
                .SingleOrDefaultAsync();
        }

        /// <summary>Gets entity by SEO URL.</summary>
        /// <param name="seoUrl"> URL of the SEO.</param>
        /// <param name="context">The context.</param>
        /// <returns>The entity by SEO URL.</returns>
        protected virtual Task<<#= name #>> GetEntityBySeoUrlAsync(
            string seoUrl,
            IClarityEcommerceEntities context)
        {
            return context.Set<<#= name #>>()
                .FilterByActive(true)
                .FilterBySeoUrl(Contract.RequiresValidKey(seoUrl), true, false)
                .SingleOrDefaultAsync();
        }
<#+          } #>

        /// <inheritdoc/>
        protected override async Task<IQueryable<<#= name #>>> FilterQueryByModelExtensionAsync(
            IQueryable<<#= name #>> query,
            I<#= modelName #>SearchModel search,
            IClarityEcommerceEntities context)
        {
            return (await base.FilterQueryByModelExtensionAsync(query, search, context).ConfigureAwait(false))
                .Filter<#= HelpFunctions.PluralizeName(name) #>BySearchModel(search);
        }

        /// <inheritdoc/>
        protected override async Task RunDefaultAssociateWorkflowsAsync(
            I<#= name #> entity,
            I<#= modelName #>Model<#= extraTypes1 #> model,
            DateTime timestamp,
            string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            await RunDefaultAssociateWorkflowsAsync(entity, model, timestamp, context).ConfigureAwait(false);
        }

        /// <inheritdoc/>
        protected override async Task RunDefaultAssociateWorkflowsAsync(
            I<#= name #> entity,
            I<#= modelName #>Model<#= extraTypes1 #> model,
            DateTime timestamp,
            IClarityEcommerceEntities context)
        {
<#+             if (td.IsIHaveJsonAttributesBase) { #>
            await Workflows.AssociateJsonAttributes.AssociateObjectsAsync(entity, model, context).ConfigureAwait(false);
            SetDefaultJsonAttributesIfNull(entity);
<#+             } #>
<#+         var propertiesToAssociate2 = theType.GetPublicProperties()
                .Where(x => x.PropertyType.IsGenericType && x.PropertyType.Name == "ICollection`1")
                .ToList();
            if (!propertiesToAssociate2.Any()) { #>
            // None to process
<#+         }
            foreach (var property in propertiesToAssociate2)
            {
                var collectionType = property.GetMethod.ReturnType.GenericTypeArguments[0];
                if (collectionType.Name == "UserClaim"
                    || collectionType.Name == "AccountUserRole"
                    || collectionType.Name == "UserRole"
                    || collectionType.Name == "RoleUser"
                    || collectionType.Name == "UserLogin"
                    || property.Name == "Children")
                { #>
            // Skipped: Not supposed to make it or fully deprecated: <#= property.Name #>
<#+                 continue;
                }
                var dontMapIn = property.GetCustomAttributes<DontMapInWithAssociateWorkflowsAttribute>().Any() || property.GetCustomAttributes<DontMapInEverAttribute>().Any();
                if (dontMapIn)
                { #>
            // Skipped: Not supposed to map this property in via this manner: <#= property.Name #>
<#+                 continue;
                }
                var td2 = new TypeDeterminer(collectionType);
                var td3 = td2.IsIAmARelationshipTable ? new TypeDeterminer(td2.RelationshipSecondaryType == theType ? td2.RelationshipPrimaryType : td2.RelationshipSecondaryType) : null; #>
<#+             if (property.Name == "Notes") { #>
            if (model.Notes != null)
            {
                if (Contract.CheckValidID(entity.ID))
                {
                    foreach (var note in model.Notes)
                    {
                        note.<#= name #>ID = entity.ID;
                    }
                }
                await Workflows.<#= name #>WithNotesAssociation.AssociateObjectsAsync(entity, model, timestamp, context).ConfigureAwait(false);
            }
<#+             } else { #>
            if (model.<#= property.Name #> != null) { await Workflows.<#= name #>With<#= property.Name #>Association.AssociateObjectsAsync(entity, model, timestamp, context).ConfigureAwait(false); }
<#+             } #>
<#+         } #>
        }

        #region Relate Workflows
<#+         foreach (PropertyInfo property in theType.GetProperties()
                .Where(x => x.CanWrite && !x.Name.EndsWith("ID") && x.GetMethod.ReturnType.Name != "ICollection`1"
                            && x.GetMethod.ReturnType.Name != "String" && x.GetMethod.ReturnType.Name != "DateTime" && x.GetMethod.ReturnType.Name != "Boolean"
                            && x.GetMethod.ReturnType.Name != "Nullable`1" && x.Name != "Parent"
                            && !x.GetCustomAttributes<DontMapInWithRelateWorkflowsAttribute>().Any()
                            && !x.GetCustomAttributes<DontMapInEverAttribute>().Any()))
            {
                PropertyInfo idProperty = theType.GetProperties().FirstOrDefault(x => x.Name == property.Name + "ID");
                if (idProperty == null) { continue; }
                string propertyName = property.Name;
                string propertyTypeName = property.GetMethod.ReturnType.Name;
                string propertyWorkflowName = HelpFunctions.PluralizeName(property.GetMethod.ReturnType.Name);
                bool isOptional = idProperty.GetMethod.ReturnType.Name == "Nullable`1";
                var dontUpdateDuringMapIn = property.GetCustomAttributes<AllowLookupAssignInWithRelateWorkflowsButDontAffectAttribute>().Any();
                var dontCreateDuringMapIn = dontUpdateDuringMapIn || property.GetCustomAttributes<AllowMapInWithRelateWorkflowsButDontAutoGenerateAttribute>().Any();
                TypeDeterminer propertyTypeTD = new TypeDeterminer(property.GetMethod.ReturnType);
                string functionName = "Relate" + (isOptional ? "Optional" : "Required") + propertyName;
                addedRelateFunctions.Add(functionName); #>
        /// <summary>Relate <#= isOptional ? "Optional " : "Required " #><#= propertyName #>.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">            The entity that has a <#= isOptional ? "Optional " : "Required " #><#= propertyName #>.</param>
        /// <param name="model">             The model that has a <#= isOptional ? "Optional " : "Required " #><#= propertyName #>.</param>
        /// <param name="timestamp">         The timestamp Date/Time.</param>
        /// <param name="contextProfileName">Name of the context profile.</param>
        protected virtual async Task <#= functionName #>Async(
            I<#= name #> entity,
            I<#= modelName #>Model<#= extraTypes1 #> model,
            DateTime timestamp,
            string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            await <#= functionName #>Async(
                    entity,
                    model,
                    timestamp,
                    context)
                .ConfigureAwait(false);
        }

        /// <summary>Relate <#= isOptional ? "Optional " : "Required " #><#= propertyName #>.</summary>
        /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
        /// <param name="entity">   The entity that has a <#= isOptional ? "Optional " : "Required " #><#= propertyName #>.</param>
        /// <param name="model">    The model that has a <#= isOptional ? "Optional " : "Required " #><#= propertyName #>.</param>
        /// <param name="timestamp">The timestamp Date/Time.</param>
        /// <param name="context">  The context.</param>
        // ReSharper disable once CyclomaticComplexity, CognitiveComplexity
        protected virtual async Task <#= functionName #>Async(
            I<#= name #> entity,
            I<#= modelName #>Model<#= extraTypes1 #> model,
            DateTime timestamp,
            IClarityEcommerceEntities context)
        {
            // Must have the core objects on both sides
            Contract.RequiresNotNull(entity);
            Contract.RequiresNotNull(model);
            // Look up the Object Model
<#+             if (dontCreateDuringMapIn || td.IsIAmARelationshipTable && propertyName == "Master") { #>
            // May resolve but not allowed to auto-generate
            var resolved = await Workflows.<#= propertyWorkflowName #>.ResolveAsync(
<#+                 if ((modelName == "Discount" || modelName == "UserProductType") && propertyName == "Master") { #>
                    byID: model.MasterID, // Master By ID
                    byKey: model.MasterKey, // Master By Key
<#+                     if (propertyTypeTD.IsINameableBase) { #>
                    byName: model.MasterName, // Master By Name
<#+                     } #>
<#+                     if (!(td.IsIAmARelationshipTable && propertyName == "Master")) { #>
                    model: null, // Ignore passing Model
<#+                     } #>
<#+                 } else { #>
                    byID: model.<#= propertyName #>ID, // By Other ID
                    byKey: model.<#= propertyName #>Key, // By Flattened Other Key
<#+                     if (propertyTypeTD.IsINameableBase) { #>
<#+                         if (propertyName == "Slave") { #>
                    byName: model.SlaveName, // Slave
<#+                         } else { #>
                    byName: model.<#= propertyName #>Name, // By Flattened Other Name
<#+                         } #>
<#+                     } #>
<#+                 } #>
<#+                 if (td.IsISalesItemBase && propertyName == "Product") { #>
                    model: null, // Skip sending Product on ISalesItemBase as it's not on the interface
<#+                 } else if (td.IsIAmARelationshipTable && propertyName == "Master" || theType.Name == "CalendarEventProduct" || theType.Name == "UserEventAttendance") { #>
                    model: null, // Skip if IAmARelationshipTable and propertyName is "Master" or CalendarEventProduct or UserEventAttendance
<#+                 } else if (modelName != "UserProductType" && modelName != "Discount" || modelName == "Discount" && propertyName != "Master") { #>
                    model: model.<#= propertyName #>, // Manual name if not UserProductType and not Discount or Discount and not Master
<#+                 } #>
                    context: context,
                    isInner: <#= isOptional ? "true" : "false" #>)
                .ConfigureAwait(false);
<#+             } else { #>
            // Allowed to auto-generate if not found
            var resolved = await Workflows.<#= propertyWorkflowName #>.ResolveWithAutoGenerateOptionalAsync(
                    byID: model.<#= propertyName #>ID, // By Other ID
<#+                 if (modelName == "Discount" && propertyName != "Store" && propertyName != "Category" && propertyName != "Product" && propertyName != "ProductType" && propertyName != "ShipCarrierMethod") { #>
                    byKey: model.CustomKey, // By direct Key
                    byName: model.Name, // By direct Name
                    model: model,
<#+                 } else { #>
<#+                     if (property.GetMethod.ReturnType.Name == typeof(PriceRounding).Name) { #>
                    byKey: model.<#= propertyName #>?.CustomKey, // By CustomKey from the sub-object
<#+                     } else { #>
                    byKey: model.<#= propertyName #>Key, // By Flattened Other Key
<#+                     } #>
<#+                     if (propertyTypeTD.IsINameableBase) { #>
<#+                         if (property.GetMethod.ReturnType.Name == typeof(StoredFile).Name) { #>
                    byName: model.<#= propertyName #>?.Name, // By Name from the sub-object
<#+                         } else if (propertyName == "Slave") { #>
                    byName: null, // Skip Name field for Slave as it's not part of the interface
<#+                             if (propertyTypeTD.IsITypableBase || propertyTypeTD.IsIStatusableBase || propertyTypeTD.IsIStateableBase) { #>
                    byDisplayName: null, // Skip Display Name field for Slave as it's not part of the interface
<#+                             } #>
<#+                         } else { #>
                    byName: model.<#= propertyName #>Name, // By Flattened Other Name
<#+                             if (propertyTypeTD.IsITypableBase || propertyTypeTD.IsIStatusableBase || propertyTypeTD.IsIStateableBase) { #>
                    byDisplayName: null, // Skip DisplayName as it's not normally part of the interface
<#+                             } #>
<#+                         } #>
<#+                     } #>
<#+                     if (td.IsIAmARelationshipTable && propertyName == "Master") { #>
                    model: null, // Ignore passing Model for Master on relationship tables, the property isn't on the interface
<#+                     } else if (td.IsISalesItemBase && propertyName == "Product") { #>
                    model: null, // Skip sending Product on ISalesItemBase as it's not on the interface
<#+                     } else { #>
                    model: model.<#= propertyName #>, // The other property as a model
<#+                     } #>
<#+                 } #>
                    context: context)
                .ConfigureAwait(false);
<#+             } #>
<#+             var altPropertyName = modelName.Contains("Discount")
                    && modelName.Contains("Applied")
                    ? "Slave"
                    : propertyName; #>
            // Check for IDs and objects
            var entityIDIsNull = !Contract.CheckValidID(entity.<#= propertyName #>ID);
            var modelIDIsNull = !Contract.CheckValidID(resolved.Result?.ID);
            var entityObjectIsNull = entity.<#= altPropertyName #> == null;
<#+            if (modelName == "Discount" && theType.Name.Contains("Applied")) { #>
            if (!resolved.ActionSucceeded && model != null)
            {
                resolved.Result = model;
            }
<#+             } else if (modelName == "Discount"
                            || td.IsIAmARelationshipTable && propertyName == "Master"
                            || theType.Name == "CalendarEventProduct"
                            || theType.Name == "UserEventAttendance") { #>
            // No fallbacks for this entity
<#+             } else if (!(td.IsISalesItemBase && propertyName == "Product")
                                && modelName != "UserProductType"
                                && !(td.IsIAmARelationshipTable && propertyName == "Master")) { #>
            if (!resolved.ActionSucceeded && model.<#= propertyName #> != null)
            {
                resolved.Result = model.<#= propertyName #>;
            }
<#+             } #>
            var modelObjectIsNull = !resolved.ActionSucceeded;
<#+             if (isOptional) { #>
            if (entityIDIsNull && modelIDIsNull && entityObjectIsNull && modelObjectIsNull)
<#+             } else { #>
            if (modelIDIsNull && modelObjectIsNull)
<#+             } #>
            {
<#+             if (isOptional) { #>
                // [Optional] Scenario 1: Nothing we can do with/to either end, so do nothing
                return;
<#+             } else { #>
                // [Required] Scenario 1: Trying to put bad data in the database
                throw new ArgumentException("Cannot assign a null to a non-nullable <#= propertyName #>ID");
<#+             } #>
            }
            var entityIDAndModelIDHaveSameID = !entityIDIsNull && !modelIDIsNull && entity.<#= propertyName #>ID == resolved.Result!.ID;
            var entityObjectAndModelObjectHaveSameID = !entityObjectIsNull && !modelObjectIsNull && entity.<#= altPropertyName #>ID == resolved.Result!.ID;
            if (entityIDAndModelIDHaveSameID || entityObjectAndModelObjectHaveSameID)
            {
<#+                 if (dontUpdateDuringMapIn) { #>
                // [Optional/Required] Scenario 2: They match IDs, but we're not allowed to update the related entity, so just return
<#+                 } else { #>
                // [Optional/Required] Scenario 2: They match IDs, just update the entity from the model if it is present
                if (!entityObjectIsNull && !modelObjectIsNull)
                {
                    entity.<#= altPropertyName #>!.Update<#= propertyTypeName #>FromModel(resolved.Result!, timestamp, timestamp);
<#+                     if (propertyTypeName == "Contact") { #>
                    // Update the Address Properties as well if available
                    if (model.<#= altPropertyName #>?.Address != null)
                    {
                        if (entity.<#= altPropertyName #>!.Address == null)
                        {
                            entity.<#= altPropertyName #>.Address = (Address)model.<#= altPropertyName #>.Address.CreateAddressEntity(timestamp, context.ContextProfileName);
                        }
                        else
                        {
                            entity.<#= altPropertyName #>.Address.UpdateAddressFromModel(model.<#= altPropertyName #>.Address, timestamp, timestamp);
                        }
                    }
<#+                     } #>
                }
<#+                 } #>
                return;
            }
            if (!modelIDIsNull)
            {
                // [Optional/Required] Scenario 3: We have IDs but they don't match, assign the model's ID to the entity's ID
                entity.<#= propertyName #>ID = resolved.Result!.ID;
                if (!modelObjectIsNull)
                {
                    if (!entityObjectIsNull)
                    {
                        // [Optional/Required] Scenario 3a: We can't update the existing object because it's the wrong one
                    }
                    else
                    {
                        // [Optional/Required] Scenario 3b: We can't assign a new object in on this entity because it would duplicate the record
                    }
                }
                return;
            }
            var modelObjectIDIsNull = !modelObjectIsNull && !Contract.CheckValidID(resolved.Result!.ID);
            var modelObjectIsActive = !modelObjectIsNull && resolved.Result!.Active;
<#+             if (isOptional) { #>
            if (!modelObjectIsNull && !modelObjectIDIsNull)
            {
                if (modelObjectIsActive)
                {
                    // [Optional] Scenario 4: We have IDs but they don't match, assign the model's ID to the entity's ID (from the model object)
                    entity.<#= propertyName #>ID = resolved.Result!.ID;
                    return;
                }
                // [Optional] Scenario 5: We have IDs but they don't match and the model has been deactivated, remove the entity from it's master
                entity.<#= propertyName #>ID = null;
                entity.<#= propertyName #> = null;
                return;
            }
            if (!entityIDIsNull && modelObjectIsActive)
            {
<#+                 if (dontCreateDuringMapIn) { #>
                // [Optional] Scenario 6: We have an entity id, but a new model, however we're not allowed to create, so throw as we can't handle this situation
                throw new InvalidOperationException("Cannot create a new record of type '<#= propertyTypeName #>' in this manner.");
<#+                 } else { #>
                // [Optional] Scenario 6: We have an entity id, but a new model, remove the id on the entity and assign the new model
                entity.<#= propertyName #>ID = null;
                entity.<#= altPropertyName #> = (<#= propertyTypeName #>)resolved.Result!.Create<#= propertyTypeName #>Entity(timestamp, context.ContextProfileName);
                return;
<#+                 } #>
            }
            if (entityIDIsNull && modelObjectIsActive)
            {
<#+                 if (dontCreateDuringMapIn) { #>
                // [Optional] Scenario 7: We don't have an entity id, and we have a new model, however we're not allowed to create, so throw as we can't handle this situation
                throw new InvalidOperationException("Cannot create a new record of type '<#= propertyTypeName #>' in this manner.");
<#+                 } else { #>
                // [Optional] Scenario 7: We don't have an entity id, and we have a new model, assign the new model
                entity.<#= propertyName #> = (<#= propertyTypeName #>)resolved.Result!.Create<#= propertyTypeName #>Entity(timestamp, context.ContextProfileName);
                return;
<#+                 } #>
            }
            if (!entityIDIsNull && modelIDIsNull && !modelObjectIsActive)
            {
                // [Optional] Scenario 8: We were removing or deactivating the object, clear it from the entity
                entity.<#= propertyName #>ID = null;
                entity.<#= propertyName #> = null;
                return;
            }
            // Note: We would do this if it wasn't just a base typable entity (like ReportType, which has extra values to adjust on the model)
            // if (!entityObjectIsNull && modelObjectIsActive && entityObjectAndModelObjectHaveSameID)
            // {
            //     // TODO: Determine 'Equals' object between the objects so we only update if different
            //     // [Optional] Scenario 9: We have data on both sides, update the object, assign the values using the Update action
            //     entity.<#= propertyName #>.Update<#= propertyTypeName #>FromModel(resolved.Result, updateTimestamp);
            //     return;
            // }
<#+             } else { #>
            if (!modelObjectIDIsNull && !modelObjectIsActive)
            {
                // [Required] Scenario 4: We have an ID on the model, but the object is inactive
                throw new InvalidOperationException("Cannot assign an inactive <#= propertyName #>ID to the <#= name #> entity");
            }
            if (!modelObjectIDIsNull)
            {
                // [Required] Scenario 5: We have IDs but they don't match, assign the model's ID to the entity's ID (from the model object)
                entity.<#= propertyName #>ID = resolved.Result!.ID;
                return;
            }
<#+                 if (dontCreateDuringMapIn) { #>
            // [Required] Scenario 6 is only allowed when allowed to Auto-Generate via Relate, skipped
<#+                 } else { #>
            if (modelObjectIsActive)
            {
                // [Required] Scenario 7: We have an entity id, but a new model, remove the id on the entity and assign the new model
                entity.<#= propertyName #>ID = 0;
<#+                 if (modelName != "UserProductType" && !(td.IsIAmARelationshipTable && propertyName == "Master")) { #>
                entity.<#= modelName.Contains("Discount") && modelName.Contains("Applied") ? "Slave" :
                    propertyName #> = (<#= propertyTypeName #>)resolved.Result!.Create<#= propertyTypeName #>Entity(timestamp, context.ContextProfileName);
<#+                 } #>
                return;
            }
<#+                 } #>
            // [Required] Scenarios 8,9 are only for Optional relationships, skipped
<#+             } #>
            // [Optional/Required] Scenario 10: Could not figure out what to do
            throw new InvalidOperationException(
                "Couldn't figure out how to relate the given <#= propertyName #> to the <#= name #> entity");
        }

<#+         } // end for loop #>
        /// <inheritdoc/>
        protected override async Task RunDefaultRelateWorkflowsAsync(
            I<#= name #> entity,
            I<#= modelName #>Model<#= extraTypes1 #> model,
            DateTime timestamp,
            string? contextProfileName)
        {
            using var context = RegistryLoaderWrapper.GetContext(contextProfileName);
            await RunDefaultRelateWorkflowsAsync(entity, model, timestamp, context).ConfigureAwait(false);
        }

        /// <inheritdoc/>
        // ReSharper disable AsyncConverter.AsyncAwaitMayBeElidedHighlighting, RedundantAwait
#pragma warning disable 1998
        protected override async Task RunDefaultRelateWorkflowsAsync(
#pragma warning restore 1998
            I<#= name #> entity,
            I<#= modelName #>Model<#= extraTypes1 #> model,
            DateTime timestamp,
            IClarityEcommerceEntities context)
        {
<#+         if (!addedRelateFunctions.Any()) { #>
            // None to process
<#+         } else { #>
            // NOTE: Can't use Task.WhenAll as the context isn't thread safe and will throw an exception is more than
            // one thing is running at the same time on the same context.
<#+         } #>
<#+         foreach (var addedRelateFunction in addedRelateFunctions) { #>
            await <#= addedRelateFunction #>Async(entity, model, timestamp, context).ConfigureAwait(false);
<#+         } #>
        }
        // ReSharper restore AsyncConverter.AsyncAwaitMayBeElidedHighlighting, RedundantAwait
        #endregion // Relate Workflows
    }
}
<#+ } // End Function GenerateStandardWorkflowTestsFile #>