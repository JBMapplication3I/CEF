<#@ template debug="false" hostspecific="true" language="C#" #><#@
output extension=".txt" #><#@
assembly name="System" #><#@
assembly name="System.ComponentModel.DataAnnotations" #><#@
assembly name="System.Configuration" #><#@
assembly name="System.Core" #><#@
assembly name="$(UserProfile)\.nuget\packages\entityframework\6.4.4\lib\net45\EntityFramework.dll" #><#@
assembly name="$(UserProfile)\.nuget\packages\servicestack.interfaces\4.5.14\lib\portable-wp80+sl5+net45+win8+wpa81+monotouch+monoandroid+xamarin.ios10\ServiceStack.Interfaces.dll" #><#@
assembly name="$(UserProfile)\.nuget\packages\servicestack.signed\4.5.14\lib\net45\ServiceStack.dll" #><#@
assembly name="$(UserProfile)\.nuget\packages\servicestack.common.signed\4.5.14\lib\net45\ServiceStack.Common.dll" #><#@
assembly name="$(UserProfile)\.nuget\packages\servicestack.Text.signed\4.5.14\lib\net45\ServiceStack.Text.dll" #><#@
assembly name="$(UserProfile)\.nuget\packages\servicestack.client.signed\4.5.14\lib\net45\ServiceStack.Client.dll" #><#@
assembly name="$(SolutionDir)01.Clarity.Ecommerce.DataModel\bin\Debug\Clarity.Ecommerce.DataModel.dll" #><#@
assembly name="$(SolutionDir)11.T4\11.T4.CodeGenerator\Bin\Debug\CodeGenerator.dll" #><#@
import namespace="System.Collections.Generic" #><#@
import namespace="System.ComponentModel.DataAnnotations" #><#@
import namespace="System.ComponentModel.DataAnnotations.Schema" #><#@
import namespace="System.Data.Entity" #><#@
import namespace="System.Linq" #><#@
import namespace="System.Reflection" #><#@
import namespace="System.Runtime.InteropServices" #><#@
import namespace="System.Text" #><#@
import namespace="System.Text.RegularExpressions" #><#@
import namespace="CodeGenerator" #><#@
import namespace="Clarity.Ecommerce.DataModel" #><#@
import namespace="Clarity.Ecommerce.Interfaces.DataModel" #><#@
import namespace="ServiceStack" #><#@
include file="$(SolutionDir)11.T4\11.T4.CodeGenerator\MultiOutput.ttinclude" #><#
var tableClasses = AppDomain.CurrentDomain.GetAssemblies()
    .Where(x => x.FullName.StartsWith("Clarity.Ecommerce.DataModel"))
    .SelectMany(x => x.GetTypes().Where(t => t.CustomAttributes.Any(at => at.AttributeType == typeof(SqlSchemaAttribute))))
    .OrderBy(x => ((SqlSchemaAttribute)Attribute.GetCustomAttribute(x, typeof(SqlSchemaAttribute))).Both)
    .GroupBy(x => ((SqlSchemaAttribute)Attribute.GetCustomAttribute(x, typeof(SqlSchemaAttribute))).Schema);
string[] skipList = new string[] { "AccountUserRole", "UserRole", "RoleUser", "Permission", "RolePermission", "UserClaim", "UserLogin", "Hangfire", "HangfireAggregatedCounter", "HangfireCounter", "HangfireHash", "HangfireJob", "HangfireJobParameter", "HangfireJobQueue", "HangfireList", "HangfireSchema", "HangfireServer", "HangfireSet", "HangfireState", "Report" };
string[] BaseProperties = new[] { "ID", "CustomKey", "CreatedDate", "UpdatedDate", "Active", "Hash" };
string[] NameableBaseProperties = new[] { "Name", "Description" };
string[] ContactableBaseProperties = new[] { "Phone", "Fax", "Email" };
string[] HaveJsonAttributesBaseProperties = new[] { "JsonAttributes", "SerializableAttributes" };
string[] TypableBaseProperties = new[] { "DisplayName", "SortOrder" };
string[] HaveSeoBaseProperties = new[] { "SeoKeywords", "SeoUrl", "SeoPageTitle", "SeoDescription", "SeoMetaData" };
#>// <autogenerated>
// <copyright file="ImportAssigners.01.Core.cs" company="clarity-ventures.com">
// Copyright (c) 2018-<#= DateTime.Today.Year #> clarity-ventures.com. All rights reserved.
// </copyright>
// <summary>Implements the import assigners class</summary>
// <summary>Implements the Import Assigners for dynamic mapping</summary>
// <remarks>This file was auto-generated by ImportAssigners.tt, changes to this
// file will be overwritten automatically when the T4 template is run again.</remarks>
// </autogenerated>
namespace Clarity.Ecommerce.Providers.SalesQuoteImporter
{
    /// <summary>An import assigners.</summary>
    public static partial class ImportAssigners
    {
        private static readonly string[] BaseProperties = { "ID", "CustomKey", "CreatedDate", "UpdatedDate", "Active", "Hash" };
        private static readonly string[] NameableBaseProperties = { "Name", "Description" };
        private static readonly string[] HaveJsonAttributesBaseProperties = { "JsonAttributes", "SerializableAttributes" };
        private static readonly string[] TypableBaseProperties = { "DisplayName", "SortOrder" };
        private static readonly string[] HaveSeoBaseProperties = { "SeoKeywords", "SeoUrl", "SeoPageTitle", "SeoDescription", "SeoMetaData" };
    }
}
<#
SaveOutput("ImportAssigners", "01.Core", "cs");
#>
// <autogenerated>
// <copyright file="ImportAssigners.02.GetProperty.cs" company="clarity-ventures.com">
// Copyright (c) 2018-<#= DateTime.Today.Year #> clarity-ventures.com. All rights reserved.
// </copyright>
// <summary>Implements the import assigners class</summary>
// <summary>Implements the Import Assigners for dynamic mapping</summary>
// <remarks>This file was auto-generated by ImportAssigners.tt, changes to this
// file will be overwritten automatically when the T4 template is run again.</remarks>
// </autogenerated>
// ReSharper disable MemberCanBePrivate.Global, MissingXmlDoc, UnusedMember.Global, UnusedMember.Local
#pragma warning disable 618, 1591
namespace Clarity.Ecommerce.Providers.SalesQuoteImporter
{
    using System;
    using System.Linq;
    using Interfaces.Models;

    public static partial class ImportAssigners
    {
        public static object GetProperty(object @object, string property)
        {
            var type = @object.GetType();
            if (BaseProperties.Contains(property) && @object is IBaseModel asIBase)
            {
                switch (property)
                {
                    case "ID": return asIBase.ID;
                    case "CustomKey": return asIBase.CustomKey;
                    case "CreatedDate": return asIBase.CreatedDate;
                    case "UpdatedDate": return asIBase.UpdatedDate;
                    case "Active": return asIBase.Active;
                    case "Hash": return asIBase.Hash;
                    default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                }
            }
            if (NameableBaseProperties.Contains(property) && @object is INameableBaseModel asINameableBase)
            {
                switch (property)
                {
                    case "Name": return asINameableBase.Name;
                    case "Description": return asINameableBase.Description;
                    default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                }
            }
            if (HaveJsonAttributesBaseProperties.Contains(property) && @object is IHaveJsonAttributesBaseModel asIHaveJsonAttributesBase)
            {
                switch (property)
                {
                    case "JsonAttributes": return asIHaveJsonAttributesBase.JsonAttributes;
                    case "SerializableAttributes": return asIHaveJsonAttributesBase.SerializableAttributes;
                    default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                }
            }
            if (TypableBaseProperties.Contains(property))
            {
                if (@object is ITypeModel asITypeModel)
                {
                    switch (property)
                    {
                        case "DisplayName": return asITypeModel.DisplayName;
                        case "SortOrder": return asITypeModel.SortOrder;
                        default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                    }
                }
                if (@object is IStatusModel asIStatusModel)
                {
                    switch (property)
                    {
                        case "DisplayName": return asIStatusModel.DisplayName;
                        case "SortOrder": return asIStatusModel.SortOrder;
                        default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                    }
                }
                if (@object is IStateModel asIStateModel)
                {
                    switch (property)
                    {
                        case "DisplayName": return asIStateModel.DisplayName;
                        case "SortOrder": return asIStateModel.SortOrder;
                        default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                    }
                }
            }
            if (HaveSeoBaseProperties.Contains(property) && @object is IHaveSeoBaseModel asIHaveSeoBase)
            {
                switch (property)
                {
                    case "SeoKeywords": return asIHaveSeoBase.SeoKeywords;
                    case "SeoUrl": return asIHaveSeoBase.SeoUrl;
                    case "SeoPageTitle": return asIHaveSeoBase.SeoPageTitle;
                    case "SeoDescription": return asIHaveSeoBase.SeoDescription;
                    case "SeoMetaData": return asIHaveSeoBase.SeoMetaData;
                    default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                }
            }
<#  foreach (var group in tableClasses) {#>
            #region <#= group.Key #>
<#      foreach (var theType in group.Where(x => !x.HasAttribute<ObsoleteAttribute>()
                                              && x.Name != "IAmExcludedFromT4Generation"
                                              && !x.GetInterfaces().Any(y => y.Name == "IAmExcludedFromT4Generation")
                                              && !skipList.Contains(x.Name)))
        {
            var td  = new TypeDeterminer(theType);
            var objectTypeText = theType.ToString().Contains("Clarity.Ecommerce.DataModel.")
                ? HelpFunctions.CleanPropertyType("Clarity.Ecommerce.DataModel", theType, true, true, false, true)
                : HelpFunctions.CleanPropertyType("Clarity.Ecommerce.DataModel", theType, false, false, false, false); #>
            if (type.GetInterfaces().Any(x => x == typeof(I<#= HelpFunctions.SwapToModelType(theType.Name) #>Model)))
            {
                switch (property)
                {
<#          var properties = theType.GetProperties()
                .Where(x => !x.HasAttribute<ObsoleteAttribute>()
                         && !x.HasAttribute<DontMapOutEverAttribute>()
                         && !x.HasAttribute<DontMapInWithRelateWorkflowsAttribute>()
                         && !x.PropertyType.GetInterfaces().Any(y => y.Name == "IAmExcludedFromT4Generation")
                         && !(x.PropertyType.Name == "ICollection`1" && x.PropertyType.GenericTypeArguments[0].GetInterfaces().Any(y => y.Name == "IAmExcludedFromT4Generation"))
                         && !BaseProperties.Contains(x.Name)
                         && !NameableBaseProperties.Contains(x.Name)
                         && !ContactableBaseProperties.Contains(x.Name)
                         && !HaveJsonAttributesBaseProperties.Contains(x.Name)
                         && !TypableBaseProperties.Contains(x.Name)
                         && !HaveSeoBaseProperties.Contains(x.Name)
                         && !(theType.Name == "User" && x.Name == "Id")
                         && !(theType.Name == "User" && x.Name == "Roles")
                         && !(theType.Name == "Account" && x.Name == "AccountUserRoles")
                         //&& !theType.Name.Contains("Discount")
                         && x.Name != "EncryptedPassword"); #>
<#          foreach (var property in properties) {
                var regex = new Regex("Subtotal(?<name>((?:Items|Shipping|Taxes|Fees|Handling|Discounts)(?!Modifier)))");
                var m = regex.Match(property.Name);
                var propName = m.Success
                    ? "Totals." + m.Groups["name"].Value.Replace("Items", "SubTotal").Replace("Taxes", "Tax")
                    : property.Name == "Total" ? "Totals.Total"
                    : theType.Name != "Note" && new[] { "SalesInvoiceItemID", "SalesOrderItemID", "PurchaseOrderItemID", "SalesQuoteItemID", "SalesReturnItemID", "SampleRequestItemID", "CartItemID" }
                        .Contains(property.Name) ? "SalesItemID"
                    : property.Name;
                if (!(td.IsIAmARelationshipTable && propName == "Master")) { #>
                    case "<#= property.Name #>": return Get<#= theType.Name #>_<#= property.Name #>(@object);
<#              } #>
<#          } #>
                    default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                }
            }
<#      } #>
            #endregion
<#  } #>
            return typeof(ImportAssigners)
                .GetMethod($"Get{@object.GetType().Name}_{property}")
                .Invoke(null, new [] { @object });
        }
    }
}
<#
SaveOutput("ImportAssigners", "02.GetProperty", "cs");
#>
// <autogenerated>
// <copyright file="ImportAssigners.03.GetTypeOfProperty.cs" company="clarity-ventures.com">
// Copyright (c) 2018-<#= DateTime.Today.Year #> clarity-ventures.com. All rights reserved.
// </copyright>
// <summary>Implements the import assigners class</summary>
// <summary>Implements the Import Assigners for dynamic mapping</summary>
// <remarks>This file was auto-generated by ImportAssigners.tt, changes to this
// file will be overwritten automatically when the T4 template is run again.</remarks>
// </autogenerated>
// ReSharper disable MemberCanBePrivate.Global, MissingXmlDoc, UnusedMember.Global, UnusedMember.Local
#pragma warning disable 618, 1591
namespace Clarity.Ecommerce.Providers.SalesQuoteImporter
{
    using System;
    using System.Linq;
    using Interfaces.Models;

    public static partial class ImportAssigners
    {
        public static Type GetTypeOfProperty(object @object, string property)
        {
            var type = @object.GetType();
            if (BaseProperties.Contains(property) && @object is IBaseModel)
            {
                switch (property)
                {
                    case "ID": return typeof(int);
                    case "CustomKey": return typeof(string);
                    case "CreatedDate": return typeof(DateTime);
                    case "UpdatedDate": return typeof(DateTime?);
                    case "Active": return typeof(bool);
                    case "Hash": return typeof(long?);
                    default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                }
            }
            if (NameableBaseProperties.Contains(property) && @object is INameableBaseModel)
            {
                switch (property)
                {
                    case "Name": return typeof(string);
                    case "Description": return typeof(string);
                    default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                }
            }
            if (HaveJsonAttributesBaseProperties.Contains(property) && @object is IHaveJsonAttributesBaseModel)
            {
                switch (property)
                {
                    case "JsonAttributes": return typeof(string);
                    case "SerializableAttributes": return typeof(SerializableAttributesDictionary);
                    default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                }
            }
            if (TypableBaseProperties.Contains(property))
            {
                if (@object is ITypeModel)
                {
                    switch (property)
                    {
                        case "DisplayName": return typeof(string);
                        case "SortOrder": return typeof(int?);
                        default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                    }
                }
                if (@object is IStatusModel)
                {
                    switch (property)
                    {
                        case "DisplayName": return typeof(string);
                        case "SortOrder": return typeof(int?);
                        default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                    }
                }
                if (@object is IStateModel)
                {
                    switch (property)
                    {
                        case "DisplayName": return typeof(string);
                        case "SortOrder": return typeof(int?);
                        default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                    }
                }
            }
            if (HaveSeoBaseProperties.Contains(property) && @object is IHaveSeoBaseModel)
            {
                switch (property)
                {
                    case "SeoKeywords": return typeof(string);
                    case "SeoUrl": return typeof(string);
                    case "SeoPageTitle": return typeof(string);
                    case "SeoDescription": return typeof(string);
                    case "SeoMetaData": return typeof(string);
                    default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                }
            }
<#  foreach (var group in tableClasses) {#>
            #region <#= group.Key #>
<#      foreach (var theType in group.Where(x => !x.HasAttribute<ObsoleteAttribute>()
                                              && x.Name != "IAmExcludedFromT4Generation"
                                              && !x.GetInterfaces().Any(y => y.Name == "IAmExcludedFromT4Generation")
                                              && !skipList.Contains(x.Name))) { #>
            if (type.GetInterfaces().Any(x => x == typeof(I<#= HelpFunctions.SwapToModelType(theType.Name) #>Model)))
            {
                switch (property)
                {
<#          var properties = theType.GetProperties()
                .Where(x => !x.HasAttribute<ObsoleteAttribute>()
                         && !x.HasAttribute<DontMapOutEverAttribute>()
                         && !x.HasAttribute<DontMapInWithRelateWorkflowsAttribute>()
                         && !x.PropertyType.GetInterfaces().Any(y => y.Name == "IAmExcludedFromT4Generation")
                         && !(x.PropertyType.Name == "ICollection`1" && x.PropertyType.GenericTypeArguments[0].GetInterfaces().Any(y => y.Name == "IAmExcludedFromT4Generation"))
                         && !BaseProperties.Contains(x.Name)
                         && !NameableBaseProperties.Contains(x.Name)
                         && !ContactableBaseProperties.Contains(x.Name)
                         && !HaveJsonAttributesBaseProperties.Contains(x.Name)
                         && !TypableBaseProperties.Contains(x.Name)
                         && !HaveSeoBaseProperties.Contains(x.Name)
                         && !(theType.Name == "User" && x.Name == "Id")
                         && !(theType.Name == "User" && x.Name == "Roles")
                         && !(theType.Name == "Account" && x.Name == "AccountUserRoles")
                         //&& !theType.Name.Contains("Discount")
                         && x.Name != "EncryptedPassword"); #>
<#          foreach (var property in properties) {#>
                    case "<#= property.Name #>": return GetConcreteTypeOf<#= theType.Name #>_<#= property.Name #>();
<#          } #>
                    default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                }
            }
<#      } #>
            #endregion
<#  } #>
            return (Type)typeof(ImportAssigners)
                .GetMethod($"GetTypeOf{type.Name}_{property}")
                .Invoke(null, new object[] { });
        }
        public static Type GetTypeOfPropertyInterface(object @object, string property)
        {
            var type = @object.GetType();
            if (BaseProperties.Contains(property) && @object is IBaseModel)
            {
                switch (property)
                {
                    case "ID": return typeof(int);
                    case "CustomKey": return typeof(string);
                    case "CreatedDate": return typeof(DateTime);
                    case "UpdatedDate": return typeof(DateTime?);
                    case "Active": return typeof(bool);
                    case "Hash": return typeof(long?);
                    default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                }
            }
            if (NameableBaseProperties.Contains(property) && @object is INameableBaseModel)
            {
                switch (property)
                {
                    case "Name": return typeof(string);
                    case "Description": return typeof(string);
                    default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                }
            }
            if (HaveJsonAttributesBaseProperties.Contains(property) && @object is IHaveJsonAttributesBaseModel)
            {
                switch (property)
                {
                    case "JsonAttributes": return typeof(string);
                    case "SerializableAttributes": return typeof(SerializableAttributesDictionary);
                    default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                }
            }
            if (TypableBaseProperties.Contains(property))
            {
                if (@object is ITypeModel)
                {
                    switch (property)
                    {
                        case "DisplayName": return typeof(string);
                        case "SortOrder": return typeof(int?);
                        default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                    }
                }
                if (@object is IStatusModel)
                {
                    switch (property)
                    {
                        case "DisplayName": return typeof(string);
                        case "SortOrder": return typeof(int?);
                        default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                    }
                }
                if (@object is IStateModel)
                {
                    switch (property)
                    {
                        case "DisplayName": return typeof(string);
                        case "SortOrder": return typeof(int?);
                        default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                    }
                }
            }
            if (HaveSeoBaseProperties.Contains(property) && @object is IHaveSeoBaseModel)
            {
                switch (property)
                {
                    case "SeoKeywords": return typeof(string);
                    case "SeoUrl": return typeof(string);
                    case "SeoPageTitle": return typeof(string);
                    case "SeoDescription": return typeof(string);
                    case "SeoMetaData": return typeof(string);
                    default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                }
            }
<#  foreach (var group in tableClasses) {#>
            #region <#= group.Key #>
<#      foreach (var theType in group.Where(x => !x.HasAttribute<ObsoleteAttribute>()
                                              && x.Name != "IAmExcludedFromT4Generation"
                                              && !x.GetInterfaces().Any(y => y.Name == "IAmExcludedFromT4Generation")
                                              && !skipList.Contains(x.Name))) { #>
            if (type.GetInterfaces().Any(x => x == typeof(I<#= HelpFunctions.SwapToModelType(theType.Name) #>Model)))
            {
                switch (property)
                {
<#          var properties = theType.GetProperties()
                .Where(x => !x.HasAttribute<ObsoleteAttribute>()
                         && !x.HasAttribute<DontMapOutEverAttribute>()
                         && !x.HasAttribute<DontMapInWithRelateWorkflowsAttribute>()
                         && !x.PropertyType.GetInterfaces().Any(y => y.Name == "IAmExcludedFromT4Generation")
                         && !(x.PropertyType.Name == "ICollection`1" && x.PropertyType.GenericTypeArguments[0].GetInterfaces().Any(y => y.Name == "IAmExcludedFromT4Generation"))
                         && !BaseProperties.Contains(x.Name)
                         && !NameableBaseProperties.Contains(x.Name)
                         && !ContactableBaseProperties.Contains(x.Name)
                         && !HaveJsonAttributesBaseProperties.Contains(x.Name)
                         && !TypableBaseProperties.Contains(x.Name)
                         && !HaveSeoBaseProperties.Contains(x.Name)
                         && !(theType.Name == "User" && x.Name == "Id")
                         && !(theType.Name == "User" && x.Name == "Roles")
                         && !(theType.Name == "Account" && x.Name == "AccountUserRoles")
                         //&& !theType.Name.Contains("Discount")
                         && x.Name != "EncryptedPassword"); #>
<#          foreach (var property in properties) {#>
                    case "<#= property.Name #>": return GetInterfaceTypeOf<#= theType.Name #>_<#= property.Name #>();
<#          } #>
                    default: throw new ArgumentException($"Unknown property '{property}' for {type.Name}");
                }
            }
<#      } #>
            #endregion
<#  } #>
            return (Type)typeof(ImportAssigners)
                .GetMethod($"GetTypeOf{type.Name}_{property}")
                .Invoke(null, new object[] { });
        }
    }
}
<#
SaveOutput("ImportAssigners", "03.GetTypeOfProperty", "cs");
#>
// <autogenerated>
// <copyright file="ImportAssigners.04.GetInnerCollectionTypeOfProperty.cs" company="clarity-ventures.com">
// Copyright (c) 2018-<#= DateTime.Today.Year #> clarity-ventures.com. All rights reserved.
// </copyright>
// <summary>Implements the import assigners class</summary>
// <summary>Implements the Import Assigners for dynamic mapping</summary>
// <remarks>This file was auto-generated by ImportAssigners.tt, changes to this
// file will be overwritten automatically when the T4 template is run again.</remarks>
// </autogenerated>
// ReSharper disable MemberCanBePrivate.Global, MissingXmlDoc, UnusedMember.Global, UnusedMember.Local
#pragma warning disable 618, 1591
namespace Clarity.Ecommerce.Providers.SalesQuoteImporter
{
    using System;

    public static partial class ImportAssigners
    {
        public static Type GetInnerCollectionTypeOfPropertyConcrete(object @object, string property)
        {
            return GetTypeOfProperty(@object, property).GenericTypeArguments[0];
        }
        public static Type GetInnerCollectionTypeOfPropertyInterface(object @object, string property)
        {
            return GetTypeOfPropertyInterface(@object, property).GenericTypeArguments[0];
        }
    }
}
<#
SaveOutput("ImportAssigners", "04.GetInnerCollectionTypeOfProperty", "cs");
#>
// <autogenerated>
// <copyright file="ImportAssigners.05.SetPropertyOrAttribute.cs" company="clarity-ventures.com">
// Copyright (c) 2018-<#= DateTime.Today.Year #> clarity-ventures.com. All rights reserved.
// </copyright>
// <summary>Implements the import assigners class</summary>
// <summary>Implements the Import Assigners for dynamic mapping</summary>
// <remarks>This file was auto-generated by ImportAssigners.tt, changes to this
// file will be overwritten automatically when the T4 template is run again.</remarks>
// </autogenerated>
// ReSharper disable MemberCanBePrivate.Global, MissingXmlDoc, UnusedMember.Global, UnusedMember.Local
#pragma warning disable 618, 1591
namespace Clarity.Ecommerce.Providers.SalesQuoteImporter
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;
    using Interfaces.Models;

    public static partial class ImportAssigners
    {
        // Set Property Values
        ////public static void SetProperty(object @object, string property, object value)
        ////{
        ////    @object.GetType().GetProperty(property).SetValue(@object, value);
        ////}
        private const BindingFlags PropertyFlags = BindingFlags.Public | BindingFlags.Instance;
        public static bool SetProperty(object model, string property, object value)
        {
            if (value == null)
            {
                return true;
            }
            var asString = value as string;
            var isString = value is string;
            if (isString && string.IsNullOrWhiteSpace(asString))
            {
                return true;
            }
            var prop = model.GetType().GetProperty(property, PropertyFlags);
            if (null == prop || !prop.CanWrite)
            {
                return true;
            }
            if (prop.PropertyType == typeof(string))
            {
                prop.SetValue(model, value);
                return true;
            }
            if (prop.PropertyType == typeof(DateTime) || prop.PropertyType == typeof(DateTime?))
            {
                prop.SetValue(model, isString ? DateTime.Parse(asString) : value);
                return true;
            }
            if (prop.PropertyType == typeof(long) || prop.PropertyType == typeof(long?))
            {
                prop.SetValue(model, isString ? long.Parse(asString) : value);
                return true;
            }
            if (prop.PropertyType == typeof(float) || prop.PropertyType == typeof(float?))
            {
                prop.SetValue(model, isString ? float.Parse(asString) : value);
                return true;
            }
            if (prop.PropertyType == typeof(double) || prop.PropertyType == typeof(double?))
            {
                prop.SetValue(model, isString ? double.Parse(asString) : value);
                return true;
            }
            if (prop.PropertyType == typeof(decimal) || prop.PropertyType == typeof(decimal?))
            {
                prop.SetValue(model, isString ? decimal.Parse(asString) : value);
                return true;
            }
            if (prop.PropertyType == typeof(int) || prop.PropertyType == typeof(int?))
            {
                prop.SetValue(model, isString ? int.Parse(asString) : value);
                return true;
            }
            if (prop.PropertyType == typeof(bool) || prop.PropertyType == typeof(bool?))
            {
                prop.SetValue(model, isString ? bool.Parse(asString) : value);
                return true;
            }
            if (prop.PropertyType.GetInterfaces().Any(x => x.Name == nameof(IBaseModel)))
            {
                prop.SetValue(model, value);
                return true;
            }
            // ReSharper disable once InvertIf
            if (prop.PropertyType.Name == typeof(List<>).Name)
            {
                var innerCollectionType = GetInnerCollectionTypeOfPropertyConcrete(model, property);
                if (value.GetType().GenericTypeArguments[0].IsInterface)
                {
                    // Up-Cast value interfaces into concretes
                    var castTMethodInfo = typeof(IEnumerable<>).GetMethod("Cast");
                    var castTMethodInfoT = castTMethodInfo.MakeGenericMethod(innerCollectionType);
                    var toListTMethodInfoT = IEnumToListMethodInfo.MakeGenericMethod(innerCollectionType);
                    var valueCastedToConcretesEnumerable = castTMethodInfoT.Invoke(null, new[] { value });
                    var valueCastedToConcretesList = toListTMethodInfoT.Invoke(null, new[] { valueCastedToConcretesEnumerable });
                    prop.SetValue(model, valueCastedToConcretesList);
                    return true;
                }
                /*if (!value.GetType().GenericTypeArguments[0].IsInterface)
                {
                    // Down-Cast value concretes into interfaces
                    var toListTMethodInfoT = IEnumToListMethodInfo.MakeGenericMethod(innerCollectionType);
                    var valueCastedToInterfacesList = toListTMethodInfoT.Invoke(null, new [] { value });
                    prop.SetValue(model, valueCastedToInterfacesList);
                    return true;
                }*/
                // Otherwise, both are either concrete or interface, so they will match
                prop.SetValue(model, value);
                return true;
            }
            return false;
        }
        // ReSharper disable InconsistentNaming, UnusedMember.Local
        private static readonly MethodInfo IEnumToListMethodInfo = typeof(Enumerable).GetMethods().Single(x => x.Name == "ToList");
        // ReSharper restore InconsistentNaming, UnusedMember.Local
        public static bool SetAttribute(object model, string key, string value)
        {
            if (string.IsNullOrEmpty(key) || string.IsNullOrEmpty(value)) { return false; }
            var sad = ((string)GetProperty(model, "JsonAttributes")).DeserializeAttributesDictionary()
                ?? new SerializableAttributesDictionary();
            //string group = null;
            string uom = null;
            // TODO@JTG: Only activate this action via a setting
            /* if (name.Contains("-"))
            {
                var array = name.Split(new[] { " - " }, StringSplitOptions.None);
                group = array[0].Trim();
                name = array[1].Trim();
                uom = array.Length > 2 ? array[2].Trim() : string.Empty;
            }*/
            var attrValue = new SerializableAttributeObject
            {
                Key = key.Trim(),
                Value = value,
                // ReSharper disable ExpressionIsAlwaysNull
                //Group = group,
                UofM = uom
                // ReSharper restore ExpressionIsAlwaysNull
            };
            sad[key.Trim()] = attrValue;
            return SetProperty(model, "JsonAttributes", sad.SerializeAttributesDictionary());
        }
    }
}
<#
SaveOutput("ImportAssigners", "05.SetPropertyOrAttribute", "cs");
#>
// <autogenerated>
// <copyright file="ImportAssigners.06.ResolveWithAutoGenerate.cs" company="clarity-ventures.com">
// Copyright (c) 2018-<#= DateTime.Today.Year #> clarity-ventures.com. All rights reserved.
// </copyright>
// <summary>Implements the import assigners class</summary>
// <summary>Implements the Import Assigners for dynamic mapping</summary>
// <remarks>This file was auto-generated by ImportAssigners.tt, changes to this
// file will be overwritten automatically when the T4 template is run again.</remarks>
// </autogenerated>
// ReSharper disable MemberCanBePrivate.Global, MissingXmlDoc, UnusedMember.Global, UnusedMember.Local
#pragma warning disable 618, 1591
namespace Clarity.Ecommerce.Providers.SalesQuoteImporter
{
    using System;
    using System.Collections.Generic;
    using System.Reflection;
    using Interfaces.Models;

    public static partial class ImportAssigners
    {
        public static int ResolveWithAutoGenerate(
            IReadOnlyList<IBaseModel> models,
            int depthLevel,
            PropertyInfo property,
            string cellDataValue)
        {
            throw new NotImplementedException();
        }
    }
}
<#
SaveOutput("ImportAssigners", "06.ResolveWithAutoGenerate", "cs");
#>
// <autogenerated>
// <copyright file="ImportAssigners.07.DbContext.cs" company="clarity-ventures.com">
// Copyright (c) 2018-<#= DateTime.Today.Year #> clarity-ventures.com. All rights reserved.
// </copyright>
// <summary>Implements the import assigners class</summary>
// <summary>Implements the Import Assigners for dynamic mapping</summary>
// <remarks>This file was auto-generated by ImportAssigners.tt, changes to this
// file will be overwritten automatically when the T4 template is run again.</remarks>
// </autogenerated>
// ReSharper disable CyclomaticComplexity, MemberCanBePrivate.Global, MissingXmlDoc, UnusedMember.Global, UnusedMember.Local
#pragma warning disable 618, 1591
namespace Clarity.Ecommerce.Providers.SalesQuoteImporter
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using DataModel;
    using Interfaces.DataModel;
    using Interfaces.Models;

    public static partial class ImportAssigners
    {
        // DbContext/DbSet/Add/Find
        public static object DbSet(IClarityEcommerceEntities context, Type type)
        {
<#  foreach (var group in tableClasses) {#>
            #region <#= group.Key #>
<#      foreach (var theType in group.Where(x => !x.HasAttribute<ObsoleteAttribute>()
                                              && x.Name != "IAmExcludedFromT4Generation"
                                              && !x.GetInterfaces().Any(y => y.Name == "IAmExcludedFromT4Generation")
                                              && !skipList.Contains(x.Name))) { #>
            if (type == typeof(<#= theType.Name #>)) { return DbSet_<#= HelpFunctions.PluralizeName(theType) #>(context); }
<#      } #>
            #endregion
<#  } #>
            throw new ArgumentException($"Unknown entity type: {type.Name}");
        }
        public static void AddToDbSet(IClarityEcommerceEntities context, Type type, object @object)
        {
<#  foreach (var group in tableClasses) {#>
            #region <#= group.Key #>
<#      foreach (var theType in group.Where(x => !x.HasAttribute<ObsoleteAttribute>()
                                              && x.Name != "IAmExcludedFromT4Generation"
                                              && !x.GetInterfaces().Any(y => y.Name == "IAmExcludedFromT4Generation")
                                              && !skipList.Contains(x.Name))) { #>
            if (type == typeof(<#= theType.Name #>)) { AddToDbSet_<#= HelpFunctions.PluralizeName(theType) #>(context, @object); }
<#      } #>
            #endregion
<#  } #>
            throw new ArgumentException($"Unknown entity type: {type.Name}");
        }
        public static int? FindFirstActiveIDInDbSet(IClarityEcommerceEntities context, Type type)
        {
            var typeName = type.Name;
            if (typeName.EndsWith("Model"))
            {
                typeName = typeName.Substring(0, typeName.Length - 5);
            }
            if (type.IsInterface)
            {
                typeName = typeName.Substring(1);
            }
            switch (typeName)
            {
<#  foreach (var group in tableClasses) {#>
                #region <#= group.Key #>
<#      foreach (var theType in group.Where(x => !x.HasAttribute<ObsoleteAttribute>()
                                              && x.Name != "IAmExcludedFromT4Generation"
                                              && !x.GetInterfaces().Any(y => y.Name == "IAmExcludedFromT4Generation")
                                              && !skipList.Contains(x.Name))) { #>
                case "<#= theType.Name #>": return FindFirstActiveIDInDbSet_<#= HelpFunctions.PluralizeName(theType) #>(context);
<#      } #>
                #endregion
<#  } #>
            }
            throw new ArgumentException($"Unknown entity type: {type.Name}");
        }
        public static object FindFirstActiveByImportGuidInDbSet(IClarityEcommerceEntities context, Type type, Guid recordGuid)
        {
<#  foreach (var group in tableClasses) {#>
            #region <#= group.Key #>
<#      foreach (var theType in group.Where(x => !x.HasAttribute<ObsoleteAttribute>()
                                              && !x.HasAttribute<IAmExcludedFromT4Generation>()
                                              && !skipList.Contains(x.Name))) { #>
            if (type == typeof(<#= theType.Name #>)) { FindFirstActiveByImportGuidInDbSet_<#= HelpFunctions.PluralizeName(theType) #>(context, recordGuid); }
<#      } #>
            #endregion
<#  } #>
            throw new ArgumentException($"Unknown entity type: {type.Name}");
        }
        public static object FindFirstActiveByImportGuidInList(IEnumerable<IBaseModel> collection, Guid recordGuid)
        {
            return collection.FirstOrDefault(
                x => x.Active
                  && x.JsonAttributes.DeserializeAttributesDictionary().ContainsKey("ImportGuid")
                  && x.JsonAttributes.DeserializeAttributesDictionary()["ImportGuid"].Value
                         == recordGuid.ToString());
        }
    }
}
<#
SaveOutput("ImportAssigners", "07.DbContext", "cs");
#>
// <autogenerated>
// <copyright file="ImportAssigners.08.Entities.cs" company="clarity-ventures.com">
// Copyright (c) 2018-<#= DateTime.Today.Year #> clarity-ventures.com. All rights reserved.
// </copyright>
// <summary>Implements the import assigners class</summary>
// <summary>Implements the Import Assigners for dynamic mapping</summary>
// <remarks>This file was auto-generated by ImportAssigners.tt, changes to this
// file will be overwritten automatically when the T4 template is run again.</remarks>
// </autogenerated>
// ReSharper disable IdentifierTypo, MemberCanBePrivate.Global, MissingXmlDoc, UnusedMember.Global, UnusedMember.Local, UnusedMethodReturnValue.Local
#pragma warning disable 618, 1591
namespace Clarity.Ecommerce.Providers.SalesQuoteImporter
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using DataModel;
    using Interfaces.DataModel;
    using Interfaces.Models;
    using Mapper;
    using Models;

    public static partial class ImportAssigners
    {
        // Individual entity calls
<#  foreach (var group in tableClasses) {#>
        #region <#= group.Key #>
<#      foreach (var theType in group.Where(x => !x.HasAttribute<ObsoleteAttribute>()
                                              && x.Name != "IAmExcludedFromT4Generation"
                                              && !x.GetInterfaces().Any(y => y.Name == "IAmExcludedFromT4Generation")
                                              && !skipList.Contains(x.Name))) { #>
        #region <#= theType.Name #>
        // Get Property Values
<#          var properties = theType.GetProperties()
                .Where(x => !x.HasAttribute<ObsoleteAttribute>()
                         && !x.HasAttribute<DontMapOutEverAttribute>()
                         && !x.HasAttribute<DontMapInWithRelateWorkflowsAttribute>()
                         && !x.PropertyType.GetInterfaces().Any(y => y.Name == "IAmExcludedFromT4Generation")
                         && !(x.PropertyType.Name == "ICollection`1" && x.PropertyType.GenericTypeArguments[0].GetInterfaces().Any(y => y.Name == "IAmExcludedFromT4Generation"))
                         && !BaseProperties.Contains(x.Name)
                         && !NameableBaseProperties.Contains(x.Name)
                         && !ContactableBaseProperties.Contains(x.Name)
                         && !HaveJsonAttributesBaseProperties.Contains(x.Name)
                         && !TypableBaseProperties.Contains(x.Name)
                         && !HaveSeoBaseProperties.Contains(x.Name)
                         && !(theType.Name == "User" && x.Name == "Id")
                         && !(theType.Name == "User" && x.Name == "Roles")
                         && !(theType.Name == "Account" && x.Name == "AccountUserRoles")
                         //&& !theType.Name.Contains("Discount")
                         && x.Name != "EncryptedPassword");
            var td = new TypeDeterminer(theType);
            var objectTypeText = theType.ToString().Contains("Clarity.Ecommerce.DataModel.")
                ? HelpFunctions.CleanPropertyType("Clarity.Ecommerce.DataModel", theType, true, true, false, true)
                : HelpFunctions.CleanPropertyType("Clarity.Ecommerce.DataModel", theType, false, false, false, false); #>
<#          foreach (var property in properties) {
                var propTypeConText = property.PropertyType.ToString().Contains("Clarity.Ecommerce.DataModel.")
                    ? HelpFunctions.CleanPropertyType("Clarity.Ecommerce.DataModel", property.PropertyType, false, true, false, true)
                    : HelpFunctions.CleanPropertyType("Clarity.Ecommerce.DataModel", property.PropertyType, false, false, false, false);
                var propTypeIntText = property.PropertyType.ToString().Contains("Clarity.Ecommerce.DataModel.")
                    ? HelpFunctions.CleanPropertyType("Clarity.Ecommerce.DataModel", property.PropertyType, true, true, false, true)
                    : HelpFunctions.CleanPropertyType("Clarity.Ecommerce.DataModel", property.PropertyType, false, false, false, false);
                var regex = new Regex("Subtotal(?<name>((?:Items|Shipping|Taxes|Fees|Handling|Discounts)(?!Modifier)))");
                var m = regex.Match(property.Name);
                var propName = m.Success
                    ? "Totals." + m.Groups["name"].Value.Replace("Items", "SubTotal").Replace("Taxes", "Tax")
                    : property.Name == "Total" ? "Totals.Total"
                    : theType.Name != "Note" && new[] { "SalesInvoiceItemID", "SalesOrderItemID", "PurchaseOrderItemID", "SalesQuoteItemID", "SalesReturnItemID", "SampleRequestItemID", "CartItemID" }
                        .Contains(property.Name) ? "SalesItemID"
                    : property.Name;
                if (!(td.IsIAmARelationshipTable && propName == "Master"))
                { #>
        private static object Get<#= theType.Name #>_<#= property.Name #>(object @object) { return ((<#= objectTypeText #><#= objectTypeText == "ISalesItemBaseModel" ? "<IApplied" + theType.Name + "DiscountModel>" : "" #>)@object).<#= propName #>; }
<#              } #>
        private static Type GetConcreteTypeOf<#= theType.Name #>_<#= property.Name #>() { return typeof(<#= propTypeConText #>); }
        private static Type GetInterfaceTypeOf<#= theType.Name #>_<#= property.Name #>() { return typeof(<#= propTypeIntText #>); }
<#              if (property.PropertyType.Name == "ICollection`1") {
                    var propTypeTextInner = property.PropertyType.GenericTypeArguments[0].ToString().Contains("Clarity.Ecommerce.DataModel.")
                        ? HelpFunctions.CleanPropertyType("Clarity.Ecommerce.DataModel", property.PropertyType.GenericTypeArguments[0], true, true, true, true)
                        : HelpFunctions.CleanPropertyType("Clarity.Ecommerce.DataModel", property.PropertyType.GenericTypeArguments[0], false, false, true, false); #>
        private static Type GetInnerCollectionTypeOf<#= theType.Name #>_<#= property.Name #>() { return typeof(<#=propTypeTextInner #>); }
<#              } #>
<#          } #>
        // Related Objects Extras
<#          foreach (var property in properties.Where(x => x.PropertyType.HasInterface(typeof(IBase)))) {#>
        // TODO: Related Property <#= property.Name #>
<#          } #>
        // Associated Objects Extras
<#          foreach (var property in properties.Where(x => x.PropertyType.Name == typeof(ICollection<>).Name)) {#>
<#              var collectionInnerTypeName = property.PropertyType.GetGenericArguments()[0].Name; #>
        private static object FindExisting_<#= collectionInnerTypeName #>_In_<#= theType.Name #>_<#= property.Name #>_Collection(object @object, object func)
        {
            return ((ICollection<<#= collectionInnerTypeName #>>)Get<#= theType.Name #>_<#= property.Name #>(@object)).FirstOrDefault((Func<<#= collectionInnerTypeName #>, bool>)func);
        }
        private static void AddNew_<#= collectionInnerTypeName #>_To_<#= theType.Name #>_<#= property.Name #>_Collection(object @object, object toAdd)
        {
            var collection = (ICollection<<#= collectionInnerTypeName #>>)Get<#= theType.Name #>_<#= property.Name #>(@object);
            collection.Add((<#= collectionInnerTypeName #>)toAdd);
            SetProperty(@object, nameof(<#= theType.Name #>.<#= property.Name #>), collection);
        }
<#          } #>
        // DbContext/DbSet/Add/Find
        private static object DbSet_<#= HelpFunctions.PluralizeName(theType) #>(IClarityEcommerceEntities context)
        {
            return context.<#= HelpFunctions.PluralizeName(theType) #>;
        }
        private static void AddToDbSet_<#= HelpFunctions.PluralizeName(theType) #>(IClarityEcommerceEntities context, object @object)
        {
            context.<#= HelpFunctions.PluralizeName(theType) #>.Add((<#= theType.Name #>)@object);
        }
        private static int? FindFirstActiveIDInDbSet_<#= HelpFunctions.PluralizeName(theType) #>(IClarityEcommerceEntities context)
        {
            return context.<#= HelpFunctions.PluralizeName(theType) #>.FilterByActive(true).Select(x => (int?)x.ID).FirstOrDefault();
        }
        private static object FindFirstActiveByImportGuidInDbSet_<#= HelpFunctions.PluralizeName(theType) #>(IClarityEcommerceEntities context, Guid recordGuid)
        {
            return context.<#= HelpFunctions.PluralizeName(theType) #>
                .FilterByActive(true)
                .FilterObjectsWithJsonAttributesByValues(new Dictionary<string, string[]> { ["ImportGuid"] = new[] { recordGuid.ToString() } })
                .SelectFirstFull<#= theType.Name #>AndMapTo<#= HelpFunctions.SwapToModelType(theType.Name) #>Model();
        }
        #endregion
<#      } #>
        #endregion
<#  }#>
    }
}
<#
SaveOutput("ImportAssigners", "08.Entities", "cs");
DeleteOldOutputs();
#>