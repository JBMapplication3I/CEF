// <autogenerated>
// <copyright file="ImportAssigners.05.SetPropertyOrAttribute.cs" company="clarity-ventures.com">
// Copyright (c) 2018-2023 clarity-ventures.com. All rights reserved.
// </copyright>
// <summary>Implements the import assigners class</summary>
// <summary>Implements the Import Assigners for dynamic mapping</summary>
// <remarks>This file was auto-generated by ImportAssigners.tt, changes to this
// file will be overwritten automatically when the T4 template is run again.</remarks>
// </autogenerated>
// ReSharper disable MemberCanBePrivate.Global, MissingXmlDoc, UnusedMember.Global, UnusedMember.Local
#pragma warning disable 618, 1591
namespace Clarity.Ecommerce.Providers.SalesQuoteImporter
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;
    using Interfaces.Models;

    public static partial class ImportAssigners
    {
        // Set Property Values
        ////public static void SetProperty(object @object, string property, object value)
        ////{
        ////    @object.GetType().GetProperty(property).SetValue(@object, value);
        ////}
        private const BindingFlags PropertyFlags = BindingFlags.Public | BindingFlags.Instance;
        public static bool SetProperty(object model, string property, object value)
        {
            if (value == null)
            {
                return true;
            }
            var asString = value as string;
            var isString = value is string;
            if (isString && string.IsNullOrWhiteSpace(asString))
            {
                return true;
            }
            var prop = model.GetType().GetProperty(property, PropertyFlags);
            if (null == prop || !prop.CanWrite)
            {
                return true;
            }
            if (prop.PropertyType == typeof(string))
            {
                prop.SetValue(model, value);
                return true;
            }
            if (prop.PropertyType == typeof(DateTime) || prop.PropertyType == typeof(DateTime?))
            {
                prop.SetValue(model, isString ? DateTime.Parse(asString) : value);
                return true;
            }
            if (prop.PropertyType == typeof(long) || prop.PropertyType == typeof(long?))
            {
                prop.SetValue(model, isString ? long.Parse(asString) : value);
                return true;
            }
            if (prop.PropertyType == typeof(float) || prop.PropertyType == typeof(float?))
            {
                prop.SetValue(model, isString ? float.Parse(asString) : value);
                return true;
            }
            if (prop.PropertyType == typeof(double) || prop.PropertyType == typeof(double?))
            {
                prop.SetValue(model, isString ? double.Parse(asString) : value);
                return true;
            }
            if (prop.PropertyType == typeof(decimal) || prop.PropertyType == typeof(decimal?))
            {
                prop.SetValue(model, isString ? decimal.Parse(asString) : value);
                return true;
            }
            if (prop.PropertyType == typeof(int) || prop.PropertyType == typeof(int?))
            {
                prop.SetValue(model, isString ? int.Parse(asString) : value);
                return true;
            }
            if (prop.PropertyType == typeof(bool) || prop.PropertyType == typeof(bool?))
            {
                prop.SetValue(model, isString ? bool.Parse(asString) : value);
                return true;
            }
            if (prop.PropertyType.GetInterfaces().Any(x => x.Name == nameof(IBaseModel)))
            {
                prop.SetValue(model, value);
                return true;
            }
            // ReSharper disable once InvertIf
            if (prop.PropertyType.Name == typeof(List<>).Name)
            {
                var innerCollectionType = GetInnerCollectionTypeOfPropertyConcrete(model, property);
                if (value.GetType().GenericTypeArguments[0].IsInterface)
                {
                    // Up-Cast value interfaces into concretes
                    var castTMethodInfo = typeof(IEnumerable<>).GetMethod("Cast");
                    var castTMethodInfoT = castTMethodInfo.MakeGenericMethod(innerCollectionType);
                    var toListTMethodInfoT = IEnumToListMethodInfo.MakeGenericMethod(innerCollectionType);
                    var valueCastedToConcretesEnumerable = castTMethodInfoT.Invoke(null, new[] { value });
                    var valueCastedToConcretesList = toListTMethodInfoT.Invoke(null, new[] { valueCastedToConcretesEnumerable });
                    prop.SetValue(model, valueCastedToConcretesList);
                    return true;
                }
                /*if (!value.GetType().GenericTypeArguments[0].IsInterface)
                {
                    // Down-Cast value concretes into interfaces
                    var toListTMethodInfoT = IEnumToListMethodInfo.MakeGenericMethod(innerCollectionType);
                    var valueCastedToInterfacesList = toListTMethodInfoT.Invoke(null, new [] { value });
                    prop.SetValue(model, valueCastedToInterfacesList);
                    return true;
                }*/
                // Otherwise, both are either concrete or interface, so they will match
                prop.SetValue(model, value);
                return true;
            }
            return false;
        }
        // ReSharper disable InconsistentNaming, UnusedMember.Local
        private static readonly MethodInfo IEnumToListMethodInfo = typeof(Enumerable).GetMethods().Single(x => x.Name == "ToList");
        // ReSharper restore InconsistentNaming, UnusedMember.Local
        public static bool SetAttribute(object model, string key, string value)
        {
            if (string.IsNullOrEmpty(key) || string.IsNullOrEmpty(value)) { return false; }
            var sad = ((string)GetProperty(model, "JsonAttributes")).DeserializeAttributesDictionary()
                ?? new SerializableAttributesDictionary();
            //string group = null;
            string uom = null;
            // TODO@JTG: Only activate this action via a setting
            /* if (name.Contains("-"))
            {
                var array = name.Split(new[] { " - " }, StringSplitOptions.None);
                group = array[0].Trim();
                name = array[1].Trim();
                uom = array.Length > 2 ? array[2].Trim() : string.Empty;
            }*/
            var attrValue = new SerializableAttributeObject
            {
                Key = key.Trim(),
                Value = value,
                // ReSharper disable ExpressionIsAlwaysNull
                //Group = group,
                UofM = uom
                // ReSharper restore ExpressionIsAlwaysNull
            };
            sad[key.Trim()] = attrValue;
            return SetProperty(model, "JsonAttributes", sad.SerializeAttributesDictionary());
        }
    }
}
